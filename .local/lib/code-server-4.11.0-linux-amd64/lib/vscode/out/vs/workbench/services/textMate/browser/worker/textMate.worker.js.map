{"version":3,"sources":["out-vscode-reh-web/vs/workbench/services/textMate/browser/worker/fake","out-vscode-reh-web/vs/workbench/services/textMate/browser/worker/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/base/common/stream.ts","out-vscode-reh-web/vs/workbench/services/textMate/browser/worker/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/base/common/buffer.ts","out-vscode-reh-web/vs/workbench/services/textMate/browser/worker/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/base/common/symbols.ts","out-vscode-reh-web/vs/workbench/services/textMate/browser/worker/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/base/common/extpath.ts","out-vscode-reh-web/vs/workbench/services/textMate/browser/worker/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/base/common/network.ts","out-vscode-reh-web/vs/workbench/services/textMate/browser/worker/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/base/common/resources.ts","out-vscode-reh-web/vs/workbench/services/textMate/browser/worker/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/base/common/async.ts","out-vscode-reh-web/vs/workbench/services/textMate/browser/worker/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/editor/common/core/eolCounter.ts","out-vscode-reh-web/vs/workbench/services/textMate/browser/worker/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/editor/common/encodedTokenAttributes.ts","out-vscode-reh-web/vs/workbench/services/textMate/browser/worker/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/editor/common/languages/nullTokenize.ts","out-vscode-reh-web/vs/workbench/services/textMate/browser/worker/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/editor/common/tokens/lineTokens.ts","out-vscode-reh-web/vs/workbench/services/textMate/browser/worker/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/editor/common/tokens/contiguousTokensEditing.ts","out-vscode-reh-web/vs/workbench/services/textMate/browser/worker/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/editor/common/tokens/contiguousMultilineTokens.ts","out-vscode-reh-web/vs/workbench/services/textMate/browser/worker/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/editor/common/tokens/contiguousMultilineTokensBuilder.ts","out-vscode-reh-web/vs/workbench/services/textMate/browser/worker/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/editor/common/model/textModelTokens.ts","out-vscode-reh-web/vs/workbench/services/textMate/browser/worker/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/workbench/services/textMate/browser/tokenizationSupport/textMateTokenizationSupport.ts","out-vscode-reh-web/vs/workbench/services/textMate/browser/worker/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/workbench/services/textMate/common/TMScopeRegistry.ts","out-vscode-reh-web/vs/workbench/services/textMate/browser/worker/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/workbench/services/textMate/common/TMGrammarFactory.ts","out-vscode-reh-web/vs/workbench/services/textMate/browser/worker/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/workbench/services/textMate/browser/worker/textMateWorkerModel.ts","out-vscode-reh-web/vs/workbench/services/textMate/browser/worker/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/workbench/services/textMate/browser/worker/textMate.worker.ts"],"sourcesContent":["}).call(this);","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { onUnexpectedError } from 'vs/base/common/errors';\nimport { DisposableStore, IDisposable, toDisposable } from 'vs/base/common/lifecycle';\n\n/**\n * The payload that flows in readable stream events.\n */\nexport type ReadableStreamEventPayload<T> = T | Error | 'end';\n\nexport interface ReadableStreamEvents<T> {\n\n\t/**\n\t * The 'data' event is emitted whenever the stream is\n\t * relinquishing ownership of a chunk of data to a consumer.\n\t *\n\t * NOTE: PLEASE UNDERSTAND THAT ADDING A DATA LISTENER CAN\n\t * TURN THE STREAM INTO FLOWING MODE. IT IS THEREFOR THE\n\t * LAST LISTENER THAT SHOULD BE ADDED AND NOT THE FIRST\n\t *\n\t * Use `listenStream` as a helper method to listen to\n\t * stream events in the right order.\n\t */\n\ton(event: 'data', callback: (data: T) => void): void;\n\n\t/**\n\t * Emitted when any error occurs.\n\t */\n\ton(event: 'error', callback: (err: Error) => void): void;\n\n\t/**\n\t * The 'end' event is emitted when there is no more data\n\t * to be consumed from the stream. The 'end' event will\n\t * not be emitted unless the data is completely consumed.\n\t */\n\ton(event: 'end', callback: () => void): void;\n}\n\n/**\n * A interface that emulates the API shape of a node.js readable\n * stream for use in native and web environments.\n */\nexport interface ReadableStream<T> extends ReadableStreamEvents<T> {\n\n\t/**\n\t * Stops emitting any events until resume() is called.\n\t */\n\tpause(): void;\n\n\t/**\n\t * Starts emitting events again after pause() was called.\n\t */\n\tresume(): void;\n\n\t/**\n\t * Destroys the stream and stops emitting any event.\n\t */\n\tdestroy(): void;\n\n\t/**\n\t * Allows to remove a listener that was previously added.\n\t */\n\tremoveListener(event: string, callback: Function): void;\n}\n\n/**\n * A interface that emulates the API shape of a node.js readable\n * for use in native and web environments.\n */\nexport interface Readable<T> {\n\n\t/**\n\t * Read data from the underlying source. Will return\n\t * null to indicate that no more data can be read.\n\t */\n\tread(): T | null;\n}\n\nexport function isReadable<T>(obj: unknown): obj is Readable<T> {\n\tconst candidate = obj as Readable<T> | undefined;\n\tif (!candidate) {\n\t\treturn false;\n\t}\n\n\treturn typeof candidate.read === 'function';\n}\n\n/**\n * A interface that emulates the API shape of a node.js writeable\n * stream for use in native and web environments.\n */\nexport interface WriteableStream<T> extends ReadableStream<T> {\n\n\t/**\n\t * Writing data to the stream will trigger the on('data')\n\t * event listener if the stream is flowing and buffer the\n\t * data otherwise until the stream is flowing.\n\t *\n\t * If a `highWaterMark` is configured and writing to the\n\t * stream reaches this mark, a promise will be returned\n\t * that should be awaited on before writing more data.\n\t * Otherwise there is a risk of buffering a large number\n\t * of data chunks without consumer.\n\t */\n\twrite(data: T): void | Promise<void>;\n\n\t/**\n\t * Signals an error to the consumer of the stream via the\n\t * on('error') handler if the stream is flowing.\n\t *\n\t * NOTE: call `end` to signal that the stream has ended,\n\t * this DOES NOT happen automatically from `error`.\n\t */\n\terror(error: Error): void;\n\n\t/**\n\t * Signals the end of the stream to the consumer. If the\n\t * result is provided, will trigger the on('data') event\n\t * listener if the stream is flowing and buffer the data\n\t * otherwise until the stream is flowing.\n\t */\n\tend(result?: T): void;\n}\n\n/**\n * A stream that has a buffer already read. Returns the original stream\n * that was read as well as the chunks that got read.\n *\n * The `ended` flag indicates if the stream has been fully consumed.\n */\nexport interface ReadableBufferedStream<T> {\n\n\t/**\n\t * The original stream that is being read.\n\t */\n\tstream: ReadableStream<T>;\n\n\t/**\n\t * An array of chunks already read from this stream.\n\t */\n\tbuffer: T[];\n\n\t/**\n\t * Signals if the stream has ended or not. If not, consumers\n\t * should continue to read from the stream until consumed.\n\t */\n\tended: boolean;\n}\n\nexport function isReadableStream<T>(obj: unknown): obj is ReadableStream<T> {\n\tconst candidate = obj as ReadableStream<T> | undefined;\n\tif (!candidate) {\n\t\treturn false;\n\t}\n\n\treturn [candidate.on, candidate.pause, candidate.resume, candidate.destroy].every(fn => typeof fn === 'function');\n}\n\nexport function isReadableBufferedStream<T>(obj: unknown): obj is ReadableBufferedStream<T> {\n\tconst candidate = obj as ReadableBufferedStream<T> | undefined;\n\tif (!candidate) {\n\t\treturn false;\n\t}\n\n\treturn isReadableStream(candidate.stream) && Array.isArray(candidate.buffer) && typeof candidate.ended === 'boolean';\n}\n\nexport interface IReducer<T, R = T> {\n\t(data: T[]): R;\n}\n\nexport interface IDataTransformer<Original, Transformed> {\n\t(data: Original): Transformed;\n}\n\nexport interface IErrorTransformer {\n\t(error: Error): Error;\n}\n\nexport interface ITransformer<Original, Transformed> {\n\tdata: IDataTransformer<Original, Transformed>;\n\terror?: IErrorTransformer;\n}\n\nexport function newWriteableStream<T>(reducer: IReducer<T>, options?: WriteableStreamOptions): WriteableStream<T> {\n\treturn new WriteableStreamImpl<T>(reducer, options);\n}\n\nexport interface WriteableStreamOptions {\n\n\t/**\n\t * The number of objects to buffer before WriteableStream#write()\n\t * signals back that the buffer is full. Can be used to reduce\n\t * the memory pressure when the stream is not flowing.\n\t */\n\thighWaterMark?: number;\n}\n\nclass WriteableStreamImpl<T> implements WriteableStream<T> {\n\n\tprivate readonly state = {\n\t\tflowing: false,\n\t\tended: false,\n\t\tdestroyed: false\n\t};\n\n\tprivate readonly buffer = {\n\t\tdata: [] as T[],\n\t\terror: [] as Error[]\n\t};\n\n\tprivate readonly listeners = {\n\t\tdata: [] as { (data: T): void }[],\n\t\terror: [] as { (error: Error): void }[],\n\t\tend: [] as { (): void }[]\n\t};\n\n\tprivate readonly pendingWritePromises: Function[] = [];\n\n\tconstructor(private reducer: IReducer<T>, private options?: WriteableStreamOptions) { }\n\n\tpause(): void {\n\t\tif (this.state.destroyed) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.state.flowing = false;\n\t}\n\n\tresume(): void {\n\t\tif (this.state.destroyed) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (!this.state.flowing) {\n\t\t\tthis.state.flowing = true;\n\n\t\t\t// emit buffered events\n\t\t\tthis.flowData();\n\t\t\tthis.flowErrors();\n\t\t\tthis.flowEnd();\n\t\t}\n\t}\n\n\twrite(data: T): void | Promise<void> {\n\t\tif (this.state.destroyed) {\n\t\t\treturn;\n\t\t}\n\n\t\t// flowing: directly send the data to listeners\n\t\tif (this.state.flowing) {\n\t\t\tthis.emitData(data);\n\t\t}\n\n\t\t// not yet flowing: buffer data until flowing\n\t\telse {\n\t\t\tthis.buffer.data.push(data);\n\n\t\t\t// highWaterMark: if configured, signal back when buffer reached limits\n\t\t\tif (typeof this.options?.highWaterMark === 'number' && this.buffer.data.length > this.options.highWaterMark) {\n\t\t\t\treturn new Promise(resolve => this.pendingWritePromises.push(resolve));\n\t\t\t}\n\t\t}\n\t}\n\n\terror(error: Error): void {\n\t\tif (this.state.destroyed) {\n\t\t\treturn;\n\t\t}\n\n\t\t// flowing: directly send the error to listeners\n\t\tif (this.state.flowing) {\n\t\t\tthis.emitError(error);\n\t\t}\n\n\t\t// not yet flowing: buffer errors until flowing\n\t\telse {\n\t\t\tthis.buffer.error.push(error);\n\t\t}\n\t}\n\n\tend(result?: T): void {\n\t\tif (this.state.destroyed) {\n\t\t\treturn;\n\t\t}\n\n\t\t// end with data if provided\n\t\tif (typeof result !== 'undefined') {\n\t\t\tthis.write(result);\n\t\t}\n\n\t\t// flowing: send end event to listeners\n\t\tif (this.state.flowing) {\n\t\t\tthis.emitEnd();\n\n\t\t\tthis.destroy();\n\t\t}\n\n\t\t// not yet flowing: remember state\n\t\telse {\n\t\t\tthis.state.ended = true;\n\t\t}\n\t}\n\n\tprivate emitData(data: T): void {\n\t\tthis.listeners.data.slice(0).forEach(listener => listener(data)); // slice to avoid listener mutation from delivering event\n\t}\n\n\tprivate emitError(error: Error): void {\n\t\tif (this.listeners.error.length === 0) {\n\t\t\tonUnexpectedError(error); // nobody listened to this error so we log it as unexpected\n\t\t} else {\n\t\t\tthis.listeners.error.slice(0).forEach(listener => listener(error)); // slice to avoid listener mutation from delivering event\n\t\t}\n\t}\n\n\tprivate emitEnd(): void {\n\t\tthis.listeners.end.slice(0).forEach(listener => listener()); // slice to avoid listener mutation from delivering event\n\t}\n\n\ton(event: 'data', callback: (data: T) => void): void;\n\ton(event: 'error', callback: (err: Error) => void): void;\n\ton(event: 'end', callback: () => void): void;\n\ton(event: 'data' | 'error' | 'end', callback: (arg0?: any) => void): void {\n\t\tif (this.state.destroyed) {\n\t\t\treturn;\n\t\t}\n\n\t\tswitch (event) {\n\t\t\tcase 'data':\n\t\t\t\tthis.listeners.data.push(callback);\n\n\t\t\t\t// switch into flowing mode as soon as the first 'data'\n\t\t\t\t// listener is added and we are not yet in flowing mode\n\t\t\t\tthis.resume();\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'end':\n\t\t\t\tthis.listeners.end.push(callback);\n\n\t\t\t\t// emit 'end' event directly if we are flowing\n\t\t\t\t// and the end has already been reached\n\t\t\t\t//\n\t\t\t\t// finish() when it went through\n\t\t\t\tif (this.state.flowing && this.flowEnd()) {\n\t\t\t\t\tthis.destroy();\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'error':\n\t\t\t\tthis.listeners.error.push(callback);\n\n\t\t\t\t// emit buffered 'error' events unless done already\n\t\t\t\t// now that we know that we have at least one listener\n\t\t\t\tif (this.state.flowing) {\n\t\t\t\t\tthis.flowErrors();\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tremoveListener(event: string, callback: Function): void {\n\t\tif (this.state.destroyed) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet listeners: unknown[] | undefined = undefined;\n\n\t\tswitch (event) {\n\t\t\tcase 'data':\n\t\t\t\tlisteners = this.listeners.data;\n\t\t\t\tbreak;\n\n\t\t\tcase 'end':\n\t\t\t\tlisteners = this.listeners.end;\n\t\t\t\tbreak;\n\n\t\t\tcase 'error':\n\t\t\t\tlisteners = this.listeners.error;\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (listeners) {\n\t\t\tconst index = listeners.indexOf(callback);\n\t\t\tif (index >= 0) {\n\t\t\t\tlisteners.splice(index, 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate flowData(): void {\n\t\tif (this.buffer.data.length > 0) {\n\t\t\tconst fullDataBuffer = this.reducer(this.buffer.data);\n\n\t\t\tthis.emitData(fullDataBuffer);\n\n\t\t\tthis.buffer.data.length = 0;\n\n\t\t\t// When the buffer is empty, resolve all pending writers\n\t\t\tconst pendingWritePromises = [...this.pendingWritePromises];\n\t\t\tthis.pendingWritePromises.length = 0;\n\t\t\tpendingWritePromises.forEach(pendingWritePromise => pendingWritePromise());\n\t\t}\n\t}\n\n\tprivate flowErrors(): void {\n\t\tif (this.listeners.error.length > 0) {\n\t\t\tfor (const error of this.buffer.error) {\n\t\t\t\tthis.emitError(error);\n\t\t\t}\n\n\t\t\tthis.buffer.error.length = 0;\n\t\t}\n\t}\n\n\tprivate flowEnd(): boolean {\n\t\tif (this.state.ended) {\n\t\t\tthis.emitEnd();\n\n\t\t\treturn this.listeners.end.length > 0;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tdestroy(): void {\n\t\tif (!this.state.destroyed) {\n\t\t\tthis.state.destroyed = true;\n\t\t\tthis.state.ended = true;\n\n\t\t\tthis.buffer.data.length = 0;\n\t\t\tthis.buffer.error.length = 0;\n\n\t\t\tthis.listeners.data.length = 0;\n\t\t\tthis.listeners.error.length = 0;\n\t\t\tthis.listeners.end.length = 0;\n\n\t\t\tthis.pendingWritePromises.length = 0;\n\t\t}\n\t}\n}\n\n/**\n * Helper to fully read a T readable into a T.\n */\nexport function consumeReadable<T>(readable: Readable<T>, reducer: IReducer<T>): T {\n\tconst chunks: T[] = [];\n\n\tlet chunk: T | null;\n\twhile ((chunk = readable.read()) !== null) {\n\t\tchunks.push(chunk);\n\t}\n\n\treturn reducer(chunks);\n}\n\n/**\n * Helper to read a T readable up to a maximum of chunks. If the limit is\n * reached, will return a readable instead to ensure all data can still\n * be read.\n */\nexport function peekReadable<T>(readable: Readable<T>, reducer: IReducer<T>, maxChunks: number): T | Readable<T> {\n\tconst chunks: T[] = [];\n\n\tlet chunk: T | null | undefined = undefined;\n\twhile ((chunk = readable.read()) !== null && chunks.length < maxChunks) {\n\t\tchunks.push(chunk);\n\t}\n\n\t// If the last chunk is null, it means we reached the end of\n\t// the readable and return all the data at once\n\tif (chunk === null && chunks.length > 0) {\n\t\treturn reducer(chunks);\n\t}\n\n\t// Otherwise, we still have a chunk, it means we reached the maxChunks\n\t// value and as such we return a new Readable that first returns\n\t// the existing read chunks and then continues with reading from\n\t// the underlying readable.\n\treturn {\n\t\tread: () => {\n\n\t\t\t// First consume chunks from our array\n\t\t\tif (chunks.length > 0) {\n\t\t\t\treturn chunks.shift()!;\n\t\t\t}\n\n\t\t\t// Then ensure to return our last read chunk\n\t\t\tif (typeof chunk !== 'undefined') {\n\t\t\t\tconst lastReadChunk = chunk;\n\n\t\t\t\t// explicitly use undefined here to indicate that we consumed\n\t\t\t\t// the chunk, which could have either been null or valued.\n\t\t\t\tchunk = undefined;\n\n\t\t\t\treturn lastReadChunk;\n\t\t\t}\n\n\t\t\t// Finally delegate back to the Readable\n\t\t\treturn readable.read();\n\t\t}\n\t};\n}\n\n/**\n * Helper to fully read a T stream into a T or consuming\n * a stream fully, awaiting all the events without caring\n * about the data.\n */\nexport function consumeStream<T, R = T>(stream: ReadableStreamEvents<T>, reducer: IReducer<T, R>): Promise<R>;\nexport function consumeStream(stream: ReadableStreamEvents<unknown>): Promise<undefined>;\nexport function consumeStream<T, R = T>(stream: ReadableStreamEvents<T>, reducer?: IReducer<T, R>): Promise<R | undefined> {\n\treturn new Promise((resolve, reject) => {\n\t\tconst chunks: T[] = [];\n\n\t\tlistenStream(stream, {\n\t\t\tonData: chunk => {\n\t\t\t\tif (reducer) {\n\t\t\t\t\tchunks.push(chunk);\n\t\t\t\t}\n\t\t\t},\n\t\t\tonError: error => {\n\t\t\t\tif (reducer) {\n\t\t\t\t\treject(error);\n\t\t\t\t} else {\n\t\t\t\t\tresolve(undefined);\n\t\t\t\t}\n\t\t\t},\n\t\t\tonEnd: () => {\n\t\t\t\tif (reducer) {\n\t\t\t\t\tresolve(reducer(chunks));\n\t\t\t\t} else {\n\t\t\t\t\tresolve(undefined);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t});\n}\n\nexport interface IStreamListener<T> {\n\n\t/**\n\t * The 'data' event is emitted whenever the stream is\n\t * relinquishing ownership of a chunk of data to a consumer.\n\t */\n\tonData(data: T): void;\n\n\t/**\n\t * Emitted when any error occurs.\n\t */\n\tonError(err: Error): void;\n\n\t/**\n\t * The 'end' event is emitted when there is no more data\n\t * to be consumed from the stream. The 'end' event will\n\t * not be emitted unless the data is completely consumed.\n\t */\n\tonEnd(): void;\n}\n\n/**\n * Helper to listen to all events of a T stream in proper order.\n */\nexport function listenStream<T>(stream: ReadableStreamEvents<T>, listener: IStreamListener<T>): IDisposable {\n\tlet destroyed = false;\n\n\tstream.on('error', error => {\n\t\tif (!destroyed) {\n\t\t\tlistener.onError(error);\n\t\t}\n\t});\n\n\tstream.on('end', () => {\n\t\tif (!destroyed) {\n\t\t\tlistener.onEnd();\n\t\t}\n\t});\n\n\t// Adding the `data` listener will turn the stream\n\t// into flowing mode. As such it is important to\n\t// add this listener last (DO NOT CHANGE!)\n\tstream.on('data', data => {\n\t\tif (!destroyed) {\n\t\t\tlistener.onData(data);\n\t\t}\n\t});\n\n\treturn toDisposable(() => destroyed = true);\n}\n\n/**\n * Helper to peek up to `maxChunks` into a stream. The return type signals if\n * the stream has ended or not. If not, caller needs to add a `data` listener\n * to continue reading.\n */\nexport function peekStream<T>(stream: ReadableStream<T>, maxChunks: number): Promise<ReadableBufferedStream<T>> {\n\treturn new Promise((resolve, reject) => {\n\t\tconst streamListeners = new DisposableStore();\n\t\tconst buffer: T[] = [];\n\n\t\t// Data Listener\n\t\tconst dataListener = (chunk: T) => {\n\n\t\t\t// Add to buffer\n\t\t\tbuffer.push(chunk);\n\n\t\t\t// We reached maxChunks and thus need to return\n\t\t\tif (buffer.length > maxChunks) {\n\n\t\t\t\t// Dispose any listeners and ensure to pause the\n\t\t\t\t// stream so that it can be consumed again by caller\n\t\t\t\tstreamListeners.dispose();\n\t\t\t\tstream.pause();\n\n\t\t\t\treturn resolve({ stream, buffer, ended: false });\n\t\t\t}\n\t\t};\n\n\t\t// Error Listener\n\t\tconst errorListener = (error: Error) => {\n\t\t\treturn reject(error);\n\t\t};\n\n\t\t// End Listener\n\t\tconst endListener = () => {\n\t\t\treturn resolve({ stream, buffer, ended: true });\n\t\t};\n\n\t\tstreamListeners.add(toDisposable(() => stream.removeListener('error', errorListener)));\n\t\tstream.on('error', errorListener);\n\n\t\tstreamListeners.add(toDisposable(() => stream.removeListener('end', endListener)));\n\t\tstream.on('end', endListener);\n\n\t\t// Important: leave the `data` listener last because\n\t\t// this can turn the stream into flowing mode and we\n\t\t// want `error` events to be received as well.\n\t\tstreamListeners.add(toDisposable(() => stream.removeListener('data', dataListener)));\n\t\tstream.on('data', dataListener);\n\t});\n}\n\n/**\n * Helper to create a readable stream from an existing T.\n */\nexport function toStream<T>(t: T, reducer: IReducer<T>): ReadableStream<T> {\n\tconst stream = newWriteableStream<T>(reducer);\n\n\tstream.end(t);\n\n\treturn stream;\n}\n\n/**\n * Helper to create an empty stream\n */\nexport function emptyStream(): ReadableStream<never> {\n\tconst stream = newWriteableStream<never>(() => { throw new Error('not supported'); });\n\tstream.end();\n\n\treturn stream;\n}\n\n/**\n * Helper to convert a T into a Readable<T>.\n */\nexport function toReadable<T>(t: T): Readable<T> {\n\tlet consumed = false;\n\n\treturn {\n\t\tread: () => {\n\t\t\tif (consumed) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconsumed = true;\n\n\t\t\treturn t;\n\t\t}\n\t};\n}\n\n/**\n * Helper to transform a readable stream into another stream.\n */\nexport function transform<Original, Transformed>(stream: ReadableStreamEvents<Original>, transformer: ITransformer<Original, Transformed>, reducer: IReducer<Transformed>): ReadableStream<Transformed> {\n\tconst target = newWriteableStream<Transformed>(reducer);\n\n\tlistenStream(stream, {\n\t\tonData: data => target.write(transformer.data(data)),\n\t\tonError: error => target.error(transformer.error ? transformer.error(error) : error),\n\t\tonEnd: () => target.end()\n\t});\n\n\treturn target;\n}\n\n/**\n * Helper to take an existing readable that will\n * have a prefix injected to the beginning.\n */\nexport function prefixedReadable<T>(prefix: T, readable: Readable<T>, reducer: IReducer<T>): Readable<T> {\n\tlet prefixHandled = false;\n\n\treturn {\n\t\tread: () => {\n\t\t\tconst chunk = readable.read();\n\n\t\t\t// Handle prefix only once\n\t\t\tif (!prefixHandled) {\n\t\t\t\tprefixHandled = true;\n\n\t\t\t\t// If we have also a read-result, make\n\t\t\t\t// sure to reduce it to a single result\n\t\t\t\tif (chunk !== null) {\n\t\t\t\t\treturn reducer([prefix, chunk]);\n\t\t\t\t}\n\n\t\t\t\t// Otherwise, just return prefix directly\n\t\t\t\treturn prefix;\n\t\t\t}\n\n\t\t\treturn chunk;\n\t\t}\n\t};\n}\n\n/**\n * Helper to take an existing stream that will\n * have a prefix injected to the beginning.\n */\nexport function prefixedStream<T>(prefix: T, stream: ReadableStream<T>, reducer: IReducer<T>): ReadableStream<T> {\n\tlet prefixHandled = false;\n\n\tconst target = newWriteableStream<T>(reducer);\n\n\tlistenStream(stream, {\n\t\tonData: data => {\n\n\t\t\t// Handle prefix only once\n\t\t\tif (!prefixHandled) {\n\t\t\t\tprefixHandled = true;\n\n\t\t\t\treturn target.write(reducer([prefix, data]));\n\t\t\t}\n\n\t\t\treturn target.write(data);\n\t\t},\n\t\tonError: error => target.error(error),\n\t\tonEnd: () => {\n\n\t\t\t// Handle prefix only once\n\t\t\tif (!prefixHandled) {\n\t\t\t\tprefixHandled = true;\n\n\t\t\t\ttarget.write(prefix);\n\t\t\t}\n\n\t\t\ttarget.end();\n\t\t}\n\t});\n\n\treturn target;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as streams from 'vs/base/common/stream';\n\ndeclare const Buffer: any;\n\nconst hasBuffer = (typeof Buffer !== 'undefined');\n\nlet textEncoder: TextEncoder | null;\nlet textDecoder: TextDecoder | null;\n\nexport class VSBuffer {\n\n\t/**\n\t * When running in a nodejs context, the backing store for the returned `VSBuffer` instance\n\t * might use a nodejs Buffer allocated from node's Buffer pool, which is not transferrable.\n\t */\n\tstatic alloc(byteLength: number): VSBuffer {\n\t\tif (hasBuffer) {\n\t\t\treturn new VSBuffer(Buffer.allocUnsafe(byteLength));\n\t\t} else {\n\t\t\treturn new VSBuffer(new Uint8Array(byteLength));\n\t\t}\n\t}\n\n\t/**\n\t * When running in a nodejs context, if `actual` is not a nodejs Buffer, the backing store for\n\t * the returned `VSBuffer` instance might use a nodejs Buffer allocated from node's Buffer pool,\n\t * which is not transferrable.\n\t */\n\tstatic wrap(actual: Uint8Array): VSBuffer {\n\t\tif (hasBuffer && !(Buffer.isBuffer(actual))) {\n\t\t\t// https://nodejs.org/dist/latest-v10.x/docs/api/buffer.html#buffer_class_method_buffer_from_arraybuffer_byteoffset_length\n\t\t\t// Create a zero-copy Buffer wrapper around the ArrayBuffer pointed to by the Uint8Array\n\t\t\tactual = Buffer.from(actual.buffer, actual.byteOffset, actual.byteLength);\n\t\t}\n\t\treturn new VSBuffer(actual);\n\t}\n\n\t/**\n\t * When running in a nodejs context, the backing store for the returned `VSBuffer` instance\n\t * might use a nodejs Buffer allocated from node's Buffer pool, which is not transferrable.\n\t */\n\tstatic fromString(source: string, options?: { dontUseNodeBuffer?: boolean }): VSBuffer {\n\t\tconst dontUseNodeBuffer = options?.dontUseNodeBuffer || false;\n\t\tif (!dontUseNodeBuffer && hasBuffer) {\n\t\t\treturn new VSBuffer(Buffer.from(source));\n\t\t} else {\n\t\t\tif (!textEncoder) {\n\t\t\t\ttextEncoder = new TextEncoder();\n\t\t\t}\n\t\t\treturn new VSBuffer(textEncoder.encode(source));\n\t\t}\n\t}\n\n\t/**\n\t * When running in a nodejs context, the backing store for the returned `VSBuffer` instance\n\t * might use a nodejs Buffer allocated from node's Buffer pool, which is not transferrable.\n\t */\n\tstatic fromByteArray(source: number[]): VSBuffer {\n\t\tconst result = VSBuffer.alloc(source.length);\n\t\tfor (let i = 0, len = source.length; i < len; i++) {\n\t\t\tresult.buffer[i] = source[i];\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * When running in a nodejs context, the backing store for the returned `VSBuffer` instance\n\t * might use a nodejs Buffer allocated from node's Buffer pool, which is not transferrable.\n\t */\n\tstatic concat(buffers: VSBuffer[], totalLength?: number): VSBuffer {\n\t\tif (typeof totalLength === 'undefined') {\n\t\t\ttotalLength = 0;\n\t\t\tfor (let i = 0, len = buffers.length; i < len; i++) {\n\t\t\t\ttotalLength += buffers[i].byteLength;\n\t\t\t}\n\t\t}\n\n\t\tconst ret = VSBuffer.alloc(totalLength);\n\t\tlet offset = 0;\n\t\tfor (let i = 0, len = buffers.length; i < len; i++) {\n\t\t\tconst element = buffers[i];\n\t\t\tret.set(element, offset);\n\t\t\toffset += element.byteLength;\n\t\t}\n\n\t\treturn ret;\n\t}\n\n\treadonly buffer: Uint8Array;\n\treadonly byteLength: number;\n\n\tprivate constructor(buffer: Uint8Array) {\n\t\tthis.buffer = buffer;\n\t\tthis.byteLength = this.buffer.byteLength;\n\t}\n\n\t/**\n\t * When running in a nodejs context, the backing store for the returned `VSBuffer` instance\n\t * might use a nodejs Buffer allocated from node's Buffer pool, which is not transferrable.\n\t */\n\tclone(): VSBuffer {\n\t\tconst result = VSBuffer.alloc(this.byteLength);\n\t\tresult.set(this);\n\t\treturn result;\n\t}\n\n\ttoString(): string {\n\t\tif (hasBuffer) {\n\t\t\treturn this.buffer.toString();\n\t\t} else {\n\t\t\tif (!textDecoder) {\n\t\t\t\ttextDecoder = new TextDecoder();\n\t\t\t}\n\t\t\treturn textDecoder.decode(this.buffer);\n\t\t}\n\t}\n\n\tslice(start?: number, end?: number): VSBuffer {\n\t\t// IMPORTANT: use subarray instead of slice because TypedArray#slice\n\t\t// creates shallow copy and NodeBuffer#slice doesn't. The use of subarray\n\t\t// ensures the same, performance, behaviour.\n\t\treturn new VSBuffer(this.buffer.subarray(start, end));\n\t}\n\n\tset(array: VSBuffer, offset?: number): void;\n\tset(array: Uint8Array, offset?: number): void;\n\tset(array: ArrayBuffer, offset?: number): void;\n\tset(array: ArrayBufferView, offset?: number): void;\n\tset(array: VSBuffer | Uint8Array | ArrayBuffer | ArrayBufferView, offset?: number): void;\n\tset(array: VSBuffer | Uint8Array | ArrayBuffer | ArrayBufferView, offset?: number): void {\n\t\tif (array instanceof VSBuffer) {\n\t\t\tthis.buffer.set(array.buffer, offset);\n\t\t} else if (array instanceof Uint8Array) {\n\t\t\tthis.buffer.set(array, offset);\n\t\t} else if (array instanceof ArrayBuffer) {\n\t\t\tthis.buffer.set(new Uint8Array(array), offset);\n\t\t} else if (ArrayBuffer.isView(array)) {\n\t\t\tthis.buffer.set(new Uint8Array(array.buffer, array.byteOffset, array.byteLength), offset);\n\t\t} else {\n\t\t\tthrow new Error(`Unknown argument 'array'`);\n\t\t}\n\t}\n\n\treadUInt32BE(offset: number): number {\n\t\treturn readUInt32BE(this.buffer, offset);\n\t}\n\n\twriteUInt32BE(value: number, offset: number): void {\n\t\twriteUInt32BE(this.buffer, value, offset);\n\t}\n\n\treadUInt32LE(offset: number): number {\n\t\treturn readUInt32LE(this.buffer, offset);\n\t}\n\n\twriteUInt32LE(value: number, offset: number): void {\n\t\twriteUInt32LE(this.buffer, value, offset);\n\t}\n\n\treadUInt8(offset: number): number {\n\t\treturn readUInt8(this.buffer, offset);\n\t}\n\n\twriteUInt8(value: number, offset: number): void {\n\t\twriteUInt8(this.buffer, value, offset);\n\t}\n}\n\nexport function readUInt16LE(source: Uint8Array, offset: number): number {\n\treturn (\n\t\t((source[offset + 0] << 0) >>> 0) |\n\t\t((source[offset + 1] << 8) >>> 0)\n\t);\n}\n\nexport function writeUInt16LE(destination: Uint8Array, value: number, offset: number): void {\n\tdestination[offset + 0] = (value & 0b11111111);\n\tvalue = value >>> 8;\n\tdestination[offset + 1] = (value & 0b11111111);\n}\n\nexport function readUInt32BE(source: Uint8Array, offset: number): number {\n\treturn (\n\t\tsource[offset] * 2 ** 24\n\t\t+ source[offset + 1] * 2 ** 16\n\t\t+ source[offset + 2] * 2 ** 8\n\t\t+ source[offset + 3]\n\t);\n}\n\nexport function writeUInt32BE(destination: Uint8Array, value: number, offset: number): void {\n\tdestination[offset + 3] = value;\n\tvalue = value >>> 8;\n\tdestination[offset + 2] = value;\n\tvalue = value >>> 8;\n\tdestination[offset + 1] = value;\n\tvalue = value >>> 8;\n\tdestination[offset] = value;\n}\n\nexport function readUInt32LE(source: Uint8Array, offset: number): number {\n\treturn (\n\t\t((source[offset + 0] << 0) >>> 0) |\n\t\t((source[offset + 1] << 8) >>> 0) |\n\t\t((source[offset + 2] << 16) >>> 0) |\n\t\t((source[offset + 3] << 24) >>> 0)\n\t);\n}\n\nexport function writeUInt32LE(destination: Uint8Array, value: number, offset: number): void {\n\tdestination[offset + 0] = (value & 0b11111111);\n\tvalue = value >>> 8;\n\tdestination[offset + 1] = (value & 0b11111111);\n\tvalue = value >>> 8;\n\tdestination[offset + 2] = (value & 0b11111111);\n\tvalue = value >>> 8;\n\tdestination[offset + 3] = (value & 0b11111111);\n}\n\nexport function readUInt8(source: Uint8Array, offset: number): number {\n\treturn source[offset];\n}\n\nexport function writeUInt8(destination: Uint8Array, value: number, offset: number): void {\n\tdestination[offset] = value;\n}\n\nexport interface VSBufferReadable extends streams.Readable<VSBuffer> { }\n\nexport interface VSBufferReadableStream extends streams.ReadableStream<VSBuffer> { }\n\nexport interface VSBufferWriteableStream extends streams.WriteableStream<VSBuffer> { }\n\nexport interface VSBufferReadableBufferedStream extends streams.ReadableBufferedStream<VSBuffer> { }\n\nexport function readableToBuffer(readable: VSBufferReadable): VSBuffer {\n\treturn streams.consumeReadable<VSBuffer>(readable, chunks => VSBuffer.concat(chunks));\n}\n\nexport function bufferToReadable(buffer: VSBuffer): VSBufferReadable {\n\treturn streams.toReadable<VSBuffer>(buffer);\n}\n\nexport function streamToBuffer(stream: streams.ReadableStream<VSBuffer>): Promise<VSBuffer> {\n\treturn streams.consumeStream<VSBuffer>(stream, chunks => VSBuffer.concat(chunks));\n}\n\nexport async function bufferedStreamToBuffer(bufferedStream: streams.ReadableBufferedStream<VSBuffer>): Promise<VSBuffer> {\n\tif (bufferedStream.ended) {\n\t\treturn VSBuffer.concat(bufferedStream.buffer);\n\t}\n\n\treturn VSBuffer.concat([\n\n\t\t// Include already read chunks...\n\t\t...bufferedStream.buffer,\n\n\t\t// ...and all additional chunks\n\t\tawait streamToBuffer(bufferedStream.stream)\n\t]);\n}\n\nexport function bufferToStream(buffer: VSBuffer): streams.ReadableStream<VSBuffer> {\n\treturn streams.toStream<VSBuffer>(buffer, chunks => VSBuffer.concat(chunks));\n}\n\nexport function streamToBufferReadableStream(stream: streams.ReadableStreamEvents<Uint8Array | string>): streams.ReadableStream<VSBuffer> {\n\treturn streams.transform<Uint8Array | string, VSBuffer>(stream, { data: data => typeof data === 'string' ? VSBuffer.fromString(data) : VSBuffer.wrap(data) }, chunks => VSBuffer.concat(chunks));\n}\n\nexport function newWriteableBufferStream(options?: streams.WriteableStreamOptions): streams.WriteableStream<VSBuffer> {\n\treturn streams.newWriteableStream<VSBuffer>(chunks => VSBuffer.concat(chunks), options);\n}\n\nexport function prefixedBufferReadable(prefix: VSBuffer, readable: VSBufferReadable): VSBufferReadable {\n\treturn streams.prefixedReadable(prefix, readable, chunks => VSBuffer.concat(chunks));\n}\n\nexport function prefixedBufferStream(prefix: VSBuffer, stream: VSBufferReadableStream): VSBufferReadableStream {\n\treturn streams.prefixedStream(prefix, stream, chunks => VSBuffer.concat(chunks));\n}\n\n/** Decodes base64 to a uint8 array. URL-encoded and unpadded base64 is allowed. */\nexport function decodeBase64(encoded: string) {\n\tlet building = 0;\n\tlet remainder = 0;\n\tlet bufi = 0;\n\n\t// The simpler way to do this is `Uint8Array.from(atob(str), c => c.charCodeAt(0))`,\n\t// but that's about 10-20x slower than this function in current Chromium versions.\n\n\tconst buffer = new Uint8Array(Math.floor(encoded.length / 4 * 3));\n\tconst append = (value: number) => {\n\t\tswitch (remainder) {\n\t\t\tcase 3:\n\t\t\t\tbuffer[bufi++] = building | value;\n\t\t\t\tremainder = 0;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tbuffer[bufi++] = building | (value >>> 2);\n\t\t\t\tbuilding = value << 6;\n\t\t\t\tremainder = 3;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tbuffer[bufi++] = building | (value >>> 4);\n\t\t\t\tbuilding = value << 4;\n\t\t\t\tremainder = 2;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbuilding = value << 2;\n\t\t\t\tremainder = 1;\n\t\t}\n\t};\n\n\tfor (let i = 0; i < encoded.length; i++) {\n\t\tconst code = encoded.charCodeAt(i);\n\t\t// See https://datatracker.ietf.org/doc/html/rfc4648#section-4\n\t\t// This branchy code is about 3x faster than an indexOf on a base64 char string.\n\t\tif (code >= 65 && code <= 90) {\n\t\t\tappend(code - 65); // A-Z starts ranges from char code 65 to 90\n\t\t} else if (code >= 97 && code <= 122) {\n\t\t\tappend(code - 97 + 26); // a-z starts ranges from char code 97 to 122, starting at byte 26\n\t\t} else if (code >= 48 && code <= 57) {\n\t\t\tappend(code - 48 + 52); // 0-9 starts ranges from char code 48 to 58, starting at byte 52\n\t\t} else if (code === 43 || code === 45) {\n\t\t\tappend(62); // \"+\" or \"-\" for URLS\n\t\t} else if (code === 47 || code === 95) {\n\t\t\tappend(63); // \"/\" or \"_\" for URLS\n\t\t} else if (code === 61) {\n\t\t\tbreak; // \"=\"\n\t\t} else {\n\t\t\tthrow new SyntaxError(`Unexpected base64 character ${encoded[i]}`);\n\t\t}\n\t}\n\n\tconst unpadded = bufi;\n\twhile (remainder > 0) {\n\t\tappend(0);\n\t}\n\n\t// slice is needed to account for overestimation due to padding\n\treturn VSBuffer.wrap(buffer).slice(0, unpadded);\n}\n\nconst base64Alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\nconst base64UrlSafeAlphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_';\n\n/** Encodes a buffer to a base64 string. */\nexport function encodeBase64({ buffer }: VSBuffer, padded = true, urlSafe = false) {\n\tconst dictionary = urlSafe ? base64UrlSafeAlphabet : base64Alphabet;\n\tlet output = '';\n\n\tconst remainder = buffer.byteLength % 3;\n\n\tlet i = 0;\n\tfor (; i < buffer.byteLength - remainder; i += 3) {\n\t\tconst a = buffer[i + 0];\n\t\tconst b = buffer[i + 1];\n\t\tconst c = buffer[i + 2];\n\n\t\toutput += dictionary[a >>> 2];\n\t\toutput += dictionary[(a << 4 | b >>> 4) & 0b111111];\n\t\toutput += dictionary[(b << 2 | c >>> 6) & 0b111111];\n\t\toutput += dictionary[c & 0b111111];\n\t}\n\n\tif (remainder === 1) {\n\t\tconst a = buffer[i + 0];\n\t\toutput += dictionary[a >>> 2];\n\t\toutput += dictionary[(a << 4) & 0b111111];\n\t\tif (padded) { output += '=='; }\n\t} else if (remainder === 2) {\n\t\tconst a = buffer[i + 0];\n\t\tconst b = buffer[i + 1];\n\t\toutput += dictionary[a >>> 2];\n\t\toutput += dictionary[(a << 4 | b >>> 4) & 0b111111];\n\t\toutput += dictionary[(b << 2) & 0b111111];\n\t\tif (padded) { output += '='; }\n\t}\n\n\treturn output;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n/**\n * Can be passed into the Delayed to defer using a microtask\n * */\nexport const MicrotaskDelay = Symbol('MicrotaskDelay');\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from 'vs/base/common/charCode';\nimport { isAbsolute, join, normalize, posix, sep } from 'vs/base/common/path';\nimport { isWindows } from 'vs/base/common/platform';\nimport { equalsIgnoreCase, rtrim, startsWithIgnoreCase } from 'vs/base/common/strings';\nimport { isNumber } from 'vs/base/common/types';\n\nexport function isPathSeparator(code: number) {\n\treturn code === CharCode.Slash || code === CharCode.Backslash;\n}\n\n/**\n * Takes a Windows OS path and changes backward slashes to forward slashes.\n * This should only be done for OS paths from Windows (or user provided paths potentially from Windows).\n * Using it on a Linux or MaxOS path might change it.\n */\nexport function toSlashes(osPath: string) {\n\treturn osPath.replace(/[\\\\/]/g, posix.sep);\n}\n\n/**\n * Takes a Windows OS path (using backward or forward slashes) and turns it into a posix path:\n * - turns backward slashes into forward slashes\n * - makes it absolute if it starts with a drive letter\n * This should only be done for OS paths from Windows (or user provided paths potentially from Windows).\n * Using it on a Linux or MaxOS path might change it.\n */\nexport function toPosixPath(osPath: string) {\n\tif (osPath.indexOf('/') === -1) {\n\t\tosPath = toSlashes(osPath);\n\t}\n\tif (/^[a-zA-Z]:(\\/|$)/.test(osPath)) { // starts with a drive letter\n\t\tosPath = '/' + osPath;\n\t}\n\treturn osPath;\n}\n\n/**\n * Computes the _root_ this path, like `getRoot('c:\\files') === c:\\`,\n * `getRoot('files:///files/path') === files:///`,\n * or `getRoot('\\\\server\\shares\\path') === \\\\server\\shares\\`\n */\nexport function getRoot(path: string, sep: string = posix.sep): string {\n\tif (!path) {\n\t\treturn '';\n\t}\n\n\tconst len = path.length;\n\tconst firstLetter = path.charCodeAt(0);\n\tif (isPathSeparator(firstLetter)) {\n\t\tif (isPathSeparator(path.charCodeAt(1))) {\n\t\t\t// UNC candidate \\\\localhost\\shares\\ddd\n\t\t\t//               ^^^^^^^^^^^^^^^^^^^\n\t\t\tif (!isPathSeparator(path.charCodeAt(2))) {\n\t\t\t\tlet pos = 3;\n\t\t\t\tconst start = pos;\n\t\t\t\tfor (; pos < len; pos++) {\n\t\t\t\t\tif (isPathSeparator(path.charCodeAt(pos))) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (start !== pos && !isPathSeparator(path.charCodeAt(pos + 1))) {\n\t\t\t\t\tpos += 1;\n\t\t\t\t\tfor (; pos < len; pos++) {\n\t\t\t\t\t\tif (isPathSeparator(path.charCodeAt(pos))) {\n\t\t\t\t\t\t\treturn path.slice(0, pos + 1) // consume this separator\n\t\t\t\t\t\t\t\t.replace(/[\\\\/]/g, sep);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// /user/far\n\t\t// ^\n\t\treturn sep;\n\n\t} else if (isWindowsDriveLetter(firstLetter)) {\n\t\t// check for windows drive letter c:\\ or c:\n\n\t\tif (path.charCodeAt(1) === CharCode.Colon) {\n\t\t\tif (isPathSeparator(path.charCodeAt(2))) {\n\t\t\t\t// C:\\fff\n\t\t\t\t// ^^^\n\t\t\t\treturn path.slice(0, 2) + sep;\n\t\t\t} else {\n\t\t\t\t// C:\n\t\t\t\t// ^^\n\t\t\t\treturn path.slice(0, 2);\n\t\t\t}\n\t\t}\n\t}\n\n\t// check for URI\n\t// scheme://authority/path\n\t// ^^^^^^^^^^^^^^^^^^^\n\tlet pos = path.indexOf('://');\n\tif (pos !== -1) {\n\t\tpos += 3; // 3 -> \"://\".length\n\t\tfor (; pos < len; pos++) {\n\t\t\tif (isPathSeparator(path.charCodeAt(pos))) {\n\t\t\t\treturn path.slice(0, pos + 1); // consume this separator\n\t\t\t}\n\t\t}\n\t}\n\n\treturn '';\n}\n\n/**\n * Check if the path follows this pattern: `\\\\hostname\\sharename`.\n *\n * @see https://msdn.microsoft.com/en-us/library/gg465305.aspx\n * @return A boolean indication if the path is a UNC path, on none-windows\n * always false.\n */\nexport function isUNC(path: string): boolean {\n\tif (!isWindows) {\n\t\t// UNC is a windows concept\n\t\treturn false;\n\t}\n\n\tif (!path || path.length < 5) {\n\t\t// at least \\\\a\\b\n\t\treturn false;\n\t}\n\n\tlet code = path.charCodeAt(0);\n\tif (code !== CharCode.Backslash) {\n\t\treturn false;\n\t}\n\n\tcode = path.charCodeAt(1);\n\n\tif (code !== CharCode.Backslash) {\n\t\treturn false;\n\t}\n\n\tlet pos = 2;\n\tconst start = pos;\n\tfor (; pos < path.length; pos++) {\n\t\tcode = path.charCodeAt(pos);\n\t\tif (code === CharCode.Backslash) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (start === pos) {\n\t\treturn false;\n\t}\n\n\tcode = path.charCodeAt(pos + 1);\n\n\tif (isNaN(code) || code === CharCode.Backslash) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n// Reference: https://en.wikipedia.org/wiki/Filename\nconst WINDOWS_INVALID_FILE_CHARS = /[\\\\/:\\*\\?\"<>\\|]/g;\nconst UNIX_INVALID_FILE_CHARS = /[\\\\/]/g;\nconst WINDOWS_FORBIDDEN_NAMES = /^(con|prn|aux|clock\\$|nul|lpt[0-9]|com[0-9])(\\.(.*?))?$/i;\nexport function isValidBasename(name: string | null | undefined, isWindowsOS: boolean = isWindows): boolean {\n\tconst invalidFileChars = isWindowsOS ? WINDOWS_INVALID_FILE_CHARS : UNIX_INVALID_FILE_CHARS;\n\n\tif (!name || name.length === 0 || /^\\s+$/.test(name)) {\n\t\treturn false; // require a name that is not just whitespace\n\t}\n\n\tinvalidFileChars.lastIndex = 0; // the holy grail of software development\n\tif (invalidFileChars.test(name)) {\n\t\treturn false; // check for certain invalid file characters\n\t}\n\n\tif (isWindowsOS && WINDOWS_FORBIDDEN_NAMES.test(name)) {\n\t\treturn false; // check for certain invalid file names\n\t}\n\n\tif (name === '.' || name === '..') {\n\t\treturn false; // check for reserved values\n\t}\n\n\tif (isWindowsOS && name[name.length - 1] === '.') {\n\t\treturn false; // Windows: file cannot end with a \".\"\n\t}\n\n\tif (isWindowsOS && name.length !== name.trim().length) {\n\t\treturn false; // Windows: file cannot end with a whitespace\n\t}\n\n\tif (name.length > 255) {\n\t\treturn false; // most file systems do not allow files > 255 length\n\t}\n\n\treturn true;\n}\n\n/**\n * @deprecated please use `IUriIdentityService.extUri.isEqual` instead. If you are\n * in a context without services, consider to pass down the `extUri` from the outside\n * or use `extUriBiasedIgnorePathCase` if you know what you are doing.\n */\nexport function isEqual(pathA: string, pathB: string, ignoreCase?: boolean): boolean {\n\tconst identityEquals = (pathA === pathB);\n\tif (!ignoreCase || identityEquals) {\n\t\treturn identityEquals;\n\t}\n\n\tif (!pathA || !pathB) {\n\t\treturn false;\n\t}\n\n\treturn equalsIgnoreCase(pathA, pathB);\n}\n\n/**\n * @deprecated please use `IUriIdentityService.extUri.isEqualOrParent` instead. If\n * you are in a context without services, consider to pass down the `extUri` from the\n * outside, or use `extUriBiasedIgnorePathCase` if you know what you are doing.\n */\nexport function isEqualOrParent(base: string, parentCandidate: string, ignoreCase?: boolean, separator = sep): boolean {\n\tif (base === parentCandidate) {\n\t\treturn true;\n\t}\n\n\tif (!base || !parentCandidate) {\n\t\treturn false;\n\t}\n\n\tif (parentCandidate.length > base.length) {\n\t\treturn false;\n\t}\n\n\tif (ignoreCase) {\n\t\tconst beginsWith = startsWithIgnoreCase(base, parentCandidate);\n\t\tif (!beginsWith) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (parentCandidate.length === base.length) {\n\t\t\treturn true; // same path, different casing\n\t\t}\n\n\t\tlet sepOffset = parentCandidate.length;\n\t\tif (parentCandidate.charAt(parentCandidate.length - 1) === separator) {\n\t\t\tsepOffset--; // adjust the expected sep offset in case our candidate already ends in separator character\n\t\t}\n\n\t\treturn base.charAt(sepOffset) === separator;\n\t}\n\n\tif (parentCandidate.charAt(parentCandidate.length - 1) !== separator) {\n\t\tparentCandidate += separator;\n\t}\n\n\treturn base.indexOf(parentCandidate) === 0;\n}\n\nexport function isWindowsDriveLetter(char0: number): boolean {\n\treturn char0 >= CharCode.A && char0 <= CharCode.Z || char0 >= CharCode.a && char0 <= CharCode.z;\n}\n\nexport function sanitizeFilePath(candidate: string, cwd: string): string {\n\n\t// Special case: allow to open a drive letter without trailing backslash\n\tif (isWindows && candidate.endsWith(':')) {\n\t\tcandidate += sep;\n\t}\n\n\t// Ensure absolute\n\tif (!isAbsolute(candidate)) {\n\t\tcandidate = join(cwd, candidate);\n\t}\n\n\t// Ensure normalized\n\tcandidate = normalize(candidate);\n\n\t// Ensure no trailing slash/backslash\n\tif (isWindows) {\n\t\tcandidate = rtrim(candidate, sep);\n\n\t\t// Special case: allow to open drive root ('C:\\')\n\t\tif (candidate.endsWith(':')) {\n\t\t\tcandidate += sep;\n\t\t}\n\n\t} else {\n\t\tcandidate = rtrim(candidate, sep);\n\n\t\t// Special case: allow to open root ('/')\n\t\tif (!candidate) {\n\t\t\tcandidate = sep;\n\t\t}\n\t}\n\n\treturn candidate;\n}\n\nexport function isRootOrDriveLetter(path: string): boolean {\n\tconst pathNormalized = normalize(path);\n\n\tif (isWindows) {\n\t\tif (path.length > 3) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn hasDriveLetter(pathNormalized) &&\n\t\t\t(path.length === 2 || pathNormalized.charCodeAt(2) === CharCode.Backslash);\n\t}\n\n\treturn pathNormalized === posix.sep;\n}\n\nexport function hasDriveLetter(path: string, isWindowsOS: boolean = isWindows): boolean {\n\tif (isWindowsOS) {\n\t\treturn isWindowsDriveLetter(path.charCodeAt(0)) && path.charCodeAt(1) === CharCode.Colon;\n\t}\n\n\treturn false;\n}\n\nexport function getDriveLetter(path: string): string | undefined {\n\treturn hasDriveLetter(path) ? path[0] : undefined;\n}\n\nexport function indexOfPath(path: string, candidate: string, ignoreCase?: boolean): number {\n\tif (candidate.length > path.length) {\n\t\treturn -1;\n\t}\n\n\tif (path === candidate) {\n\t\treturn 0;\n\t}\n\n\tif (ignoreCase) {\n\t\tpath = path.toLowerCase();\n\t\tcandidate = candidate.toLowerCase();\n\t}\n\n\treturn path.indexOf(candidate);\n}\n\nexport interface IPathWithLineAndColumn {\n\tpath: string;\n\tline?: number;\n\tcolumn?: number;\n}\n\nexport function parseLineAndColumnAware(rawPath: string): IPathWithLineAndColumn {\n\tconst segments = rawPath.split(':'); // C:\\file.txt:<line>:<column>\n\n\tlet path: string | undefined = undefined;\n\tlet line: number | undefined = undefined;\n\tlet column: number | undefined = undefined;\n\n\tfor (const segment of segments) {\n\t\tconst segmentAsNumber = Number(segment);\n\t\tif (!isNumber(segmentAsNumber)) {\n\t\t\tpath = !!path ? [path, segment].join(':') : segment; // a colon can well be part of a path (e.g. C:\\...)\n\t\t} else if (line === undefined) {\n\t\t\tline = segmentAsNumber;\n\t\t} else if (column === undefined) {\n\t\t\tcolumn = segmentAsNumber;\n\t\t}\n\t}\n\n\tif (!path) {\n\t\tthrow new Error('Format for `--goto` should be: `FILE:LINE(:COLUMN)`');\n\t}\n\n\treturn {\n\t\tpath,\n\t\tline: line !== undefined ? line : undefined,\n\t\tcolumn: column !== undefined ? column : line !== undefined ? 1 : undefined // if we have a line, make sure column is also set\n\t};\n}\n\nconst pathChars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n\nexport function randomPath(parent?: string, prefix?: string, randomLength = 8): string {\n\tlet suffix = '';\n\tfor (let i = 0; i < randomLength; i++) {\n\t\tsuffix += pathChars.charAt(Math.floor(Math.random() * pathChars.length));\n\t}\n\n\tlet randomFileName: string;\n\tif (prefix) {\n\t\trandomFileName = `${prefix}-${suffix}`;\n\t} else {\n\t\trandomFileName = suffix;\n\t}\n\n\tif (parent) {\n\t\treturn join(parent, randomFileName);\n\t}\n\n\treturn randomFileName;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as errors from 'vs/base/common/errors';\nimport * as platform from 'vs/base/common/platform';\nimport { URI } from 'vs/base/common/uri';\n\nexport namespace Schemas {\n\n\t/**\n\t * A schema that is used for models that exist in memory\n\t * only and that have no correspondence on a server or such.\n\t */\n\texport const inMemory = 'inmemory';\n\n\t/**\n\t * A schema that is used for setting files\n\t */\n\texport const vscode = 'vscode';\n\n\t/**\n\t * A schema that is used for internal private files\n\t */\n\texport const internal = 'private';\n\n\t/**\n\t * A walk-through document.\n\t */\n\texport const walkThrough = 'walkThrough';\n\n\t/**\n\t * An embedded code snippet.\n\t */\n\texport const walkThroughSnippet = 'walkThroughSnippet';\n\n\texport const http = 'http';\n\n\texport const https = 'https';\n\n\texport const file = 'file';\n\n\texport const mailto = 'mailto';\n\n\texport const untitled = 'untitled';\n\n\texport const data = 'data';\n\n\texport const command = 'command';\n\n\texport const vscodeRemote = 'vscode-remote';\n\n\texport const vscodeRemoteResource = 'vscode-remote-resource';\n\n\texport const vscodeUserData = 'vscode-userdata';\n\n\texport const vscodeCustomEditor = 'vscode-custom-editor';\n\n\texport const vscodeNotebookCell = 'vscode-notebook-cell';\n\n\texport const vscodeNotebookCellMetadata = 'vscode-notebook-cell-metadata';\n\texport const vscodeNotebookCellOutput = 'vscode-notebook-cell-output';\n\texport const vscodeInteractive = 'vscode-interactive';\n\texport const vscodeInteractiveInput = 'vscode-interactive-input';\n\n\texport const vscodeSettings = 'vscode-settings';\n\n\texport const vscodeWorkspaceTrust = 'vscode-workspace-trust';\n\n\texport const vscodeTerminal = 'vscode-terminal';\n\n\t/**\n\t * Scheme used internally for webviews that aren't linked to a resource (i.e. not custom editors)\n\t */\n\texport const webviewPanel = 'webview-panel';\n\n\t/**\n\t * Scheme used for loading the wrapper html and script in webviews.\n\t */\n\texport const vscodeWebview = 'vscode-webview';\n\n\t/**\n\t * Scheme used for extension pages\n\t */\n\texport const extension = 'extension';\n\n\t/**\n\t * Scheme used as a replacement of `file` scheme to load\n\t * files with our custom protocol handler (desktop only).\n\t */\n\texport const vscodeFileResource = 'vscode-file';\n\n\t/**\n\t * Scheme used for temporary resources\n\t */\n\texport const tmp = 'tmp';\n\n\t/**\n\t * Scheme used vs live share\n\t */\n\texport const vsls = 'vsls';\n\n\t/**\n\t * Scheme used for the Source Control commit input's text document\n\t */\n\texport const vscodeSourceControl = 'vscode-scm';\n}\n\nexport const connectionTokenCookieName = 'vscode-tkn';\nexport const connectionTokenQueryName = 'tkn';\n\nclass RemoteAuthoritiesImpl {\n\tprivate readonly _hosts: { [authority: string]: string | undefined } = Object.create(null);\n\tprivate readonly _ports: { [authority: string]: number | undefined } = Object.create(null);\n\tprivate readonly _connectionTokens: { [authority: string]: string | undefined } = Object.create(null);\n\tprivate _preferredWebSchema: 'http' | 'https' = 'http';\n\tprivate _delegate: ((uri: URI) => URI) | null = null;\n\tprivate _remoteResourcesPath: string = `/${Schemas.vscodeRemoteResource}`;\n\n\tsetPreferredWebSchema(schema: 'http' | 'https') {\n\t\tthis._preferredWebSchema = schema;\n\t}\n\n\tsetDelegate(delegate: (uri: URI) => URI): void {\n\t\tthis._delegate = delegate;\n\t}\n\n\tsetServerRootPath(serverRootPath: string): void {\n\t\tthis._remoteResourcesPath = `${serverRootPath}/${Schemas.vscodeRemoteResource}`;\n\t}\n\n\tset(authority: string, host: string, port: number): void {\n\t\tthis._hosts[authority] = host;\n\t\tthis._ports[authority] = port;\n\t}\n\n\tsetConnectionToken(authority: string, connectionToken: string): void {\n\t\tthis._connectionTokens[authority] = connectionToken;\n\t}\n\n\tgetPreferredWebSchema(): 'http' | 'https' {\n\t\treturn this._preferredWebSchema;\n\t}\n\n\trewrite(uri: URI): URI {\n\t\tif (this._delegate) {\n\t\t\ttry {\n\t\t\t\treturn this._delegate(uri);\n\t\t\t} catch (err) {\n\t\t\t\terrors.onUnexpectedError(err);\n\t\t\t\treturn uri;\n\t\t\t}\n\t\t}\n\t\tconst authority = uri.authority;\n\t\tlet host = this._hosts[authority];\n\t\tif (host && host.indexOf(':') !== -1 && host.indexOf('[') === -1) {\n\t\t\thost = `[${host}]`;\n\t\t}\n\t\tconst port = this._ports[authority];\n\t\tconst connectionToken = this._connectionTokens[authority];\n\t\tlet query = `path=${encodeURIComponent(uri.path)}`;\n\t\tif (typeof connectionToken === 'string') {\n\t\t\tquery += `&${connectionTokenQueryName}=${encodeURIComponent(connectionToken)}`;\n\t\t}\n\t\treturn URI.from({\n\t\t\tscheme: platform.isWeb ? this._preferredWebSchema : Schemas.vscodeRemoteResource,\n\t\t\tauthority: `${host}:${port}`,\n\t\t\tpath: platform.isWeb\n\t\t\t\t? (window.location.pathname + \"/\" + this._remoteResourcesPath).replace(/\\/\\/+/g, \"/\")\n\t\t\t\t: this._remoteResourcesPath,\n\t\t\tquery\n\t\t});\n\t}\n}\n\nexport const RemoteAuthorities = new RemoteAuthoritiesImpl();\n\n/**\n * A string pointing to a path inside the app. It should not begin with ./ or ../\n */\nexport type AppResourcePath = (\n\t`a${string}` | `b${string}` | `c${string}` | `d${string}` | `e${string}` | `f${string}`\n\t| `g${string}` | `h${string}` | `i${string}` | `j${string}` | `k${string}` | `l${string}`\n\t| `m${string}` | `n${string}` | `o${string}` | `p${string}` | `q${string}` | `r${string}`\n\t| `s${string}` | `t${string}` | `u${string}` | `v${string}` | `w${string}` | `x${string}`\n\t| `y${string}` | `z${string}`\n);\n\nexport const builtinExtensionsPath: AppResourcePath = 'vs/../../extensions';\nexport const nodeModulesPath: AppResourcePath = 'vs/../../node_modules';\nexport const nodeModulesAsarPath: AppResourcePath = 'vs/../../node_modules.asar';\nexport const nodeModulesAsarUnpackedPath: AppResourcePath = 'vs/../../node_modules.asar.unpacked';\n\nclass FileAccessImpl {\n\n\tprivate static readonly FALLBACK_AUTHORITY = 'vscode-app';\n\n\t/**\n\t * Returns a URI to use in contexts where the browser is responsible\n\t * for loading (e.g. fetch()) or when used within the DOM.\n\t *\n\t * **Note:** use `dom.ts#asCSSUrl` whenever the URL is to be used in CSS context.\n\t */\n\tasBrowserUri(resourcePath: AppResourcePath | ''): URI {\n\t\tconst uri = this.toUri(resourcePath, require);\n\t\treturn this.uriToBrowserUri(uri);\n\t}\n\n\t/**\n\t * Returns a URI to use in contexts where the browser is responsible\n\t * for loading (e.g. fetch()) or when used within the DOM.\n\t *\n\t * **Note:** use `dom.ts#asCSSUrl` whenever the URL is to be used in CSS context.\n\t */\n\turiToBrowserUri(uri: URI): URI {\n\t\t// Handle remote URIs via `RemoteAuthorities`\n\t\tif (uri.scheme === Schemas.vscodeRemote) {\n\t\t\treturn RemoteAuthorities.rewrite(uri);\n\t\t}\n\n\t\t// Convert to `vscode-file` resource..\n\t\tif (\n\t\t\t// ...only ever for `file` resources\n\t\t\turi.scheme === Schemas.file &&\n\t\t\t(\n\t\t\t\t// ...and we run in native environments\n\t\t\t\tplatform.isNative ||\n\t\t\t\t// ...or web worker extensions on desktop\n\t\t\t\t(platform.isWebWorker && platform.globals.origin === `${Schemas.vscodeFileResource}://${FileAccessImpl.FALLBACK_AUTHORITY}`)\n\t\t\t)\n\t\t) {\n\t\t\treturn uri.with({\n\t\t\t\tscheme: Schemas.vscodeFileResource,\n\t\t\t\t// We need to provide an authority here so that it can serve\n\t\t\t\t// as origin for network and loading matters in chromium.\n\t\t\t\t// If the URI is not coming with an authority already, we\n\t\t\t\t// add our own\n\t\t\t\tauthority: uri.authority || FileAccessImpl.FALLBACK_AUTHORITY,\n\t\t\t\tquery: null,\n\t\t\t\tfragment: null\n\t\t\t});\n\t\t}\n\n\t\treturn uri;\n\t}\n\n\t/**\n\t * Returns the `file` URI to use in contexts where node.js\n\t * is responsible for loading.\n\t */\n\tasFileUri(resourcePath: AppResourcePath | ''): URI {\n\t\tconst uri = this.toUri(resourcePath, require);\n\t\treturn this.uriToFileUri(uri);\n\t}\n\n\t/**\n\t * Returns the `file` URI to use in contexts where node.js\n\t * is responsible for loading.\n\t */\n\turiToFileUri(uri: URI): URI {\n\t\t// Only convert the URI if it is `vscode-file:` scheme\n\t\tif (uri.scheme === Schemas.vscodeFileResource) {\n\t\t\treturn uri.with({\n\t\t\t\tscheme: Schemas.file,\n\t\t\t\t// Only preserve the `authority` if it is different from\n\t\t\t\t// our fallback authority. This ensures we properly preserve\n\t\t\t\t// Windows UNC paths that come with their own authority.\n\t\t\t\tauthority: uri.authority !== FileAccessImpl.FALLBACK_AUTHORITY ? uri.authority : null,\n\t\t\t\tquery: null,\n\t\t\t\tfragment: null\n\t\t\t});\n\t\t}\n\n\t\treturn uri;\n\t}\n\n\tprivate toUri(uriOrModule: URI | string, moduleIdToUrl: { toUrl(moduleId: string): string }): URI {\n\t\tif (URI.isUri(uriOrModule)) {\n\t\t\treturn uriOrModule;\n\t\t}\n\n\t\treturn URI.parse(moduleIdToUrl.toUrl(uriOrModule));\n\t}\n}\n\nexport const FileAccess = new FileAccessImpl();\n\n\nexport namespace COI {\n\n\tconst coiHeaders = new Map<'3' | '2' | '1' | string, Record<string, string>>([\n\t\t['1', { 'Cross-Origin-Opener-Policy': 'same-origin' }],\n\t\t['2', { 'Cross-Origin-Embedder-Policy': 'require-corp' }],\n\t\t['3', { 'Cross-Origin-Opener-Policy': 'same-origin', 'Cross-Origin-Embedder-Policy': 'require-corp' }],\n\t]);\n\n\texport const CoopAndCoep = Object.freeze(coiHeaders.get('3'));\n\n\tconst coiSearchParamName = 'vscode-coi';\n\n\t/**\n\t * Extract desired headers from `vscode-coi` invocation\n\t */\n\texport function getHeadersFromQuery(url: string | URI | URL): Record<string, string> | undefined {\n\t\tlet params: URLSearchParams | undefined;\n\t\tif (typeof url === 'string') {\n\t\t\tparams = new URL(url).searchParams;\n\t\t} else if (url instanceof URL) {\n\t\t\tparams = url.searchParams;\n\t\t} else if (URI.isUri(url)) {\n\t\t\tparams = new URL(url.toString(true)).searchParams;\n\t\t}\n\t\tconst value = params?.get(coiSearchParamName);\n\t\tif (!value) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn coiHeaders.get(value);\n\t}\n\n\t/**\n\t * Add the `vscode-coi` query attribute based on wanting `COOP` and `COEP`. Will be a noop when `crossOriginIsolated`\n\t * isn't enabled the current context\n\t */\n\texport function addSearchParam(urlOrSearch: URLSearchParams | Record<string, string>, coop: boolean, coep: boolean): void {\n\t\tif (!(<any>globalThis).crossOriginIsolated) {\n\t\t\t// depends on the current context being COI\n\t\t\treturn;\n\t\t}\n\t\tconst value = coop && coep ? '3' : coep ? '2' : '1';\n\t\tif (urlOrSearch instanceof URLSearchParams) {\n\t\t\turlOrSearch.set(coiSearchParamName, value);\n\t\t} else {\n\t\t\t(<Record<string, string>>urlOrSearch)[coiSearchParamName] = value;\n\t\t}\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from 'vs/base/common/charCode';\nimport * as extpath from 'vs/base/common/extpath';\nimport { Schemas } from 'vs/base/common/network';\nimport * as paths from 'vs/base/common/path';\nimport { isLinux, isWindows } from 'vs/base/common/platform';\nimport { compare as strCompare, equalsIgnoreCase } from 'vs/base/common/strings';\nimport { URI, uriToFsPath } from 'vs/base/common/uri';\n\nexport function originalFSPath(uri: URI): string {\n\treturn uriToFsPath(uri, true);\n}\n\n//#region IExtUri\n\nexport interface IExtUri {\n\n\t// --- identity\n\n\t/**\n\t * Compares two uris.\n\t *\n\t * @param uri1 Uri\n\t * @param uri2 Uri\n\t * @param ignoreFragment Ignore the fragment (defaults to `false`)\n\t */\n\tcompare(uri1: URI, uri2: URI, ignoreFragment?: boolean): number;\n\n\t/**\n\t * Tests whether two uris are equal\n\t *\n\t * @param uri1 Uri\n\t * @param uri2 Uri\n\t * @param ignoreFragment Ignore the fragment (defaults to `false`)\n\t */\n\tisEqual(uri1: URI | undefined, uri2: URI | undefined, ignoreFragment?: boolean): boolean;\n\n\t/**\n\t * Tests whether a `candidate` URI is a parent or equal of a given `base` URI.\n\t *\n\t * @param base A uri which is \"longer\" or at least same length as `parentCandidate`\n\t * @param parentCandidate A uri which is \"shorter\" or up to same length as `base`\n\t * @param ignoreFragment Ignore the fragment (defaults to `false`)\n\t */\n\tisEqualOrParent(base: URI, parentCandidate: URI, ignoreFragment?: boolean): boolean;\n\n\t/**\n\t * Creates a key from a resource URI to be used to resource comparison and for resource maps.\n\t * @see {@link ResourceMap}\n\t * @param uri Uri\n\t * @param ignoreFragment Ignore the fragment (defaults to `false`)\n\t */\n\tgetComparisonKey(uri: URI, ignoreFragment?: boolean): string;\n\n\t/**\n\t * Whether the casing of the path-component of the uri should be ignored.\n\t */\n\tignorePathCasing(uri: URI): boolean;\n\n\t// --- path math\n\n\tbasenameOrAuthority(resource: URI): string;\n\n\t/**\n\t * Returns the basename of the path component of an uri.\n\t * @param resource\n\t */\n\tbasename(resource: URI): string;\n\n\t/**\n\t * Returns the extension of the path component of an uri.\n\t * @param resource\n\t */\n\textname(resource: URI): string;\n\t/**\n\t * Return a URI representing the directory of a URI path.\n\t *\n\t * @param resource The input URI.\n\t * @returns The URI representing the directory of the input URI.\n\t */\n\tdirname(resource: URI): URI;\n\t/**\n\t * Join a URI path with path fragments and normalizes the resulting path.\n\t *\n\t * @param resource The input URI.\n\t * @param pathFragment The path fragment to add to the URI path.\n\t * @returns The resulting URI.\n\t */\n\tjoinPath(resource: URI, ...pathFragment: string[]): URI;\n\t/**\n\t * Normalizes the path part of a URI: Resolves `.` and `..` elements with directory names.\n\t *\n\t * @param resource The URI to normalize the path.\n\t * @returns The URI with the normalized path.\n\t */\n\tnormalizePath(resource: URI): URI;\n\t/**\n\t *\n\t * @param from\n\t * @param to\n\t */\n\trelativePath(from: URI, to: URI): string | undefined;\n\t/**\n\t * Resolves an absolute or relative path against a base URI.\n\t * The path can be relative or absolute posix or a Windows path\n\t */\n\tresolvePath(base: URI, path: string): URI;\n\n\t// --- misc\n\n\t/**\n\t * Returns true if the URI path is absolute.\n\t */\n\tisAbsolutePath(resource: URI): boolean;\n\t/**\n\t * Tests whether the two authorities are the same\n\t */\n\tisEqualAuthority(a1: string, a2: string): boolean;\n\t/**\n\t * Returns true if the URI path has a trailing path separator\n\t */\n\thasTrailingPathSeparator(resource: URI, sep?: string): boolean;\n\t/**\n\t * Removes a trailing path separator, if there's one.\n\t * Important: Doesn't remove the first slash, it would make the URI invalid\n\t */\n\tremoveTrailingPathSeparator(resource: URI, sep?: string): URI;\n\t/**\n\t * Adds a trailing path separator to the URI if there isn't one already.\n\t * For example, c:\\ would be unchanged, but c:\\users would become c:\\users\\\n\t */\n\taddTrailingPathSeparator(resource: URI, sep?: string): URI;\n}\n\nexport class ExtUri implements IExtUri {\n\n\tconstructor(private _ignorePathCasing: (uri: URI) => boolean) { }\n\n\tcompare(uri1: URI, uri2: URI, ignoreFragment: boolean = false): number {\n\t\tif (uri1 === uri2) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn strCompare(this.getComparisonKey(uri1, ignoreFragment), this.getComparisonKey(uri2, ignoreFragment));\n\t}\n\n\tisEqual(uri1: URI | undefined, uri2: URI | undefined, ignoreFragment: boolean = false): boolean {\n\t\tif (uri1 === uri2) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!uri1 || !uri2) {\n\t\t\treturn false;\n\t\t}\n\t\treturn this.getComparisonKey(uri1, ignoreFragment) === this.getComparisonKey(uri2, ignoreFragment);\n\t}\n\n\tgetComparisonKey(uri: URI, ignoreFragment: boolean = false): string {\n\t\treturn uri.with({\n\t\t\tpath: this._ignorePathCasing(uri) ? uri.path.toLowerCase() : undefined,\n\t\t\tfragment: ignoreFragment ? null : undefined\n\t\t}).toString();\n\t}\n\n\tignorePathCasing(uri: URI): boolean {\n\t\treturn this._ignorePathCasing(uri);\n\t}\n\n\tisEqualOrParent(base: URI, parentCandidate: URI, ignoreFragment: boolean = false): boolean {\n\t\tif (base.scheme === parentCandidate.scheme) {\n\t\t\tif (base.scheme === Schemas.file) {\n\t\t\t\treturn extpath.isEqualOrParent(originalFSPath(base), originalFSPath(parentCandidate), this._ignorePathCasing(base)) && base.query === parentCandidate.query && (ignoreFragment || base.fragment === parentCandidate.fragment);\n\t\t\t}\n\t\t\tif (isEqualAuthority(base.authority, parentCandidate.authority)) {\n\t\t\t\treturn extpath.isEqualOrParent(base.path, parentCandidate.path, this._ignorePathCasing(base), '/') && base.query === parentCandidate.query && (ignoreFragment || base.fragment === parentCandidate.fragment);\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t// --- path math\n\n\tjoinPath(resource: URI, ...pathFragment: string[]): URI {\n\t\treturn URI.joinPath(resource, ...pathFragment);\n\t}\n\n\tbasenameOrAuthority(resource: URI): string {\n\t\treturn basename(resource) || resource.authority;\n\t}\n\n\tbasename(resource: URI): string {\n\t\treturn paths.posix.basename(resource.path);\n\t}\n\n\textname(resource: URI): string {\n\t\treturn paths.posix.extname(resource.path);\n\t}\n\n\tdirname(resource: URI): URI {\n\t\tif (resource.path.length === 0) {\n\t\t\treturn resource;\n\t\t}\n\t\tlet dirname;\n\t\tif (resource.scheme === Schemas.file) {\n\t\t\tdirname = URI.file(paths.dirname(originalFSPath(resource))).path;\n\t\t} else {\n\t\t\tdirname = paths.posix.dirname(resource.path);\n\t\t\tif (resource.authority && dirname.length && dirname.charCodeAt(0) !== CharCode.Slash) {\n\t\t\t\tconsole.error(`dirname(\"${resource.toString})) resulted in a relative path`);\n\t\t\t\tdirname = '/'; // If a URI contains an authority component, then the path component must either be empty or begin with a CharCode.Slash (\"/\") character\n\t\t\t}\n\t\t}\n\t\treturn resource.with({\n\t\t\tpath: dirname\n\t\t});\n\t}\n\n\tnormalizePath(resource: URI): URI {\n\t\tif (!resource.path.length) {\n\t\t\treturn resource;\n\t\t}\n\t\tlet normalizedPath: string;\n\t\tif (resource.scheme === Schemas.file) {\n\t\t\tnormalizedPath = URI.file(paths.normalize(originalFSPath(resource))).path;\n\t\t} else {\n\t\t\tnormalizedPath = paths.posix.normalize(resource.path);\n\t\t}\n\t\treturn resource.with({\n\t\t\tpath: normalizedPath\n\t\t});\n\t}\n\n\trelativePath(from: URI, to: URI): string | undefined {\n\t\tif (from.scheme !== to.scheme || !isEqualAuthority(from.authority, to.authority)) {\n\t\t\treturn undefined;\n\t\t}\n\t\tif (from.scheme === Schemas.file) {\n\t\t\tconst relativePath = paths.relative(originalFSPath(from), originalFSPath(to));\n\t\t\treturn isWindows ? extpath.toSlashes(relativePath) : relativePath;\n\t\t}\n\t\tlet fromPath = from.path || '/';\n\t\tconst toPath = to.path || '/';\n\t\tif (this._ignorePathCasing(from)) {\n\t\t\t// make casing of fromPath match toPath\n\t\t\tlet i = 0;\n\t\t\tfor (const len = Math.min(fromPath.length, toPath.length); i < len; i++) {\n\t\t\t\tif (fromPath.charCodeAt(i) !== toPath.charCodeAt(i)) {\n\t\t\t\t\tif (fromPath.charAt(i).toLowerCase() !== toPath.charAt(i).toLowerCase()) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfromPath = toPath.substr(0, i) + fromPath.substr(i);\n\t\t}\n\t\treturn paths.posix.relative(fromPath, toPath);\n\t}\n\n\tresolvePath(base: URI, path: string): URI {\n\t\tif (base.scheme === Schemas.file) {\n\t\t\tconst newURI = URI.file(paths.resolve(originalFSPath(base), path));\n\t\t\treturn base.with({\n\t\t\t\tauthority: newURI.authority,\n\t\t\t\tpath: newURI.path\n\t\t\t});\n\t\t}\n\t\tpath = extpath.toPosixPath(path); // we allow path to be a windows path\n\t\treturn base.with({\n\t\t\tpath: paths.posix.resolve(base.path, path)\n\t\t});\n\t}\n\n\t// --- misc\n\n\tisAbsolutePath(resource: URI): boolean {\n\t\treturn !!resource.path && resource.path[0] === '/';\n\t}\n\n\tisEqualAuthority(a1: string | undefined, a2: string | undefined) {\n\t\treturn a1 === a2 || (a1 !== undefined && a2 !== undefined && equalsIgnoreCase(a1, a2));\n\t}\n\n\thasTrailingPathSeparator(resource: URI, sep: string = paths.sep): boolean {\n\t\tif (resource.scheme === Schemas.file) {\n\t\t\tconst fsp = originalFSPath(resource);\n\t\t\treturn fsp.length > extpath.getRoot(fsp).length && fsp[fsp.length - 1] === sep;\n\t\t} else {\n\t\t\tconst p = resource.path;\n\t\t\treturn (p.length > 1 && p.charCodeAt(p.length - 1) === CharCode.Slash) && !(/^[a-zA-Z]:(\\/$|\\\\$)/.test(resource.fsPath)); // ignore the slash at offset 0\n\t\t}\n\t}\n\n\tremoveTrailingPathSeparator(resource: URI, sep: string = paths.sep): URI {\n\t\t// Make sure that the path isn't a drive letter. A trailing separator there is not removable.\n\t\tif (hasTrailingPathSeparator(resource, sep)) {\n\t\t\treturn resource.with({ path: resource.path.substr(0, resource.path.length - 1) });\n\t\t}\n\t\treturn resource;\n\t}\n\n\taddTrailingPathSeparator(resource: URI, sep: string = paths.sep): URI {\n\t\tlet isRootSep: boolean = false;\n\t\tif (resource.scheme === Schemas.file) {\n\t\t\tconst fsp = originalFSPath(resource);\n\t\t\tisRootSep = ((fsp !== undefined) && (fsp.length === extpath.getRoot(fsp).length) && (fsp[fsp.length - 1] === sep));\n\t\t} else {\n\t\t\tsep = '/';\n\t\t\tconst p = resource.path;\n\t\t\tisRootSep = p.length === 1 && p.charCodeAt(p.length - 1) === CharCode.Slash;\n\t\t}\n\t\tif (!isRootSep && !hasTrailingPathSeparator(resource, sep)) {\n\t\t\treturn resource.with({ path: resource.path + '/' });\n\t\t}\n\t\treturn resource;\n\t}\n}\n\n\n/**\n * Unbiased utility that takes uris \"as they are\". This means it can be interchanged with\n * uri#toString() usages. The following is true\n * ```\n * assertEqual(aUri.toString() === bUri.toString(), exturi.isEqual(aUri, bUri))\n * ```\n */\nexport const extUri = new ExtUri(() => false);\n\n/**\n * BIASED utility that _mostly_ ignored the case of urs paths. ONLY use this util if you\n * understand what you are doing.\n *\n * This utility is INCOMPATIBLE with `uri.toString()`-usages and both CANNOT be used interchanged.\n *\n * When dealing with uris from files or documents, `extUri` (the unbiased friend)is sufficient\n * because those uris come from a \"trustworthy source\". When creating unknown uris it's always\n * better to use `IUriIdentityService` which exposes an `IExtUri`-instance which knows when path\n * casing matters.\n */\nexport const extUriBiasedIgnorePathCase = new ExtUri(uri => {\n\t// A file scheme resource is in the same platform as code, so ignore case for non linux platforms\n\t// Resource can be from another platform. Lowering the case as an hack. Should come from File system provider\n\treturn uri.scheme === Schemas.file ? !isLinux : true;\n});\n\n\n/**\n * BIASED utility that always ignores the casing of uris paths. ONLY use this util if you\n * understand what you are doing.\n *\n * This utility is INCOMPATIBLE with `uri.toString()`-usages and both CANNOT be used interchanged.\n *\n * When dealing with uris from files or documents, `extUri` (the unbiased friend)is sufficient\n * because those uris come from a \"trustworthy source\". When creating unknown uris it's always\n * better to use `IUriIdentityService` which exposes an `IExtUri`-instance which knows when path\n * casing matters.\n */\nexport const extUriIgnorePathCase = new ExtUri(_ => true);\n\nexport const isEqual = extUri.isEqual.bind(extUri);\nexport const isEqualOrParent = extUri.isEqualOrParent.bind(extUri);\nexport const getComparisonKey = extUri.getComparisonKey.bind(extUri);\nexport const basenameOrAuthority = extUri.basenameOrAuthority.bind(extUri);\nexport const basename = extUri.basename.bind(extUri);\nexport const extname = extUri.extname.bind(extUri);\nexport const dirname = extUri.dirname.bind(extUri);\nexport const joinPath = extUri.joinPath.bind(extUri);\nexport const normalizePath = extUri.normalizePath.bind(extUri);\nexport const relativePath = extUri.relativePath.bind(extUri);\nexport const resolvePath = extUri.resolvePath.bind(extUri);\nexport const isAbsolutePath = extUri.isAbsolutePath.bind(extUri);\nexport const isEqualAuthority = extUri.isEqualAuthority.bind(extUri);\nexport const hasTrailingPathSeparator = extUri.hasTrailingPathSeparator.bind(extUri);\nexport const removeTrailingPathSeparator = extUri.removeTrailingPathSeparator.bind(extUri);\nexport const addTrailingPathSeparator = extUri.addTrailingPathSeparator.bind(extUri);\n\n//#endregion\n\nexport function distinctParents<T>(items: T[], resourceAccessor: (item: T) => URI): T[] {\n\tconst distinctParents: T[] = [];\n\tfor (let i = 0; i < items.length; i++) {\n\t\tconst candidateResource = resourceAccessor(items[i]);\n\t\tif (items.some((otherItem, index) => {\n\t\t\tif (index === i) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn isEqualOrParent(candidateResource, resourceAccessor(otherItem));\n\t\t})) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tdistinctParents.push(items[i]);\n\t}\n\n\treturn distinctParents;\n}\n\n/**\n * Data URI related helpers.\n */\nexport namespace DataUri {\n\n\texport const META_DATA_LABEL = 'label';\n\texport const META_DATA_DESCRIPTION = 'description';\n\texport const META_DATA_SIZE = 'size';\n\texport const META_DATA_MIME = 'mime';\n\n\texport function parseMetaData(dataUri: URI): Map<string, string> {\n\t\tconst metadata = new Map<string, string>();\n\n\t\t// Given a URI of:  data:image/png;size:2313;label:SomeLabel;description:SomeDescription;base64,77+9UE5...\n\t\t// the metadata is: size:2313;label:SomeLabel;description:SomeDescription\n\t\tconst meta = dataUri.path.substring(dataUri.path.indexOf(';') + 1, dataUri.path.lastIndexOf(';'));\n\t\tmeta.split(';').forEach(property => {\n\t\t\tconst [key, value] = property.split(':');\n\t\t\tif (key && value) {\n\t\t\t\tmetadata.set(key, value);\n\t\t\t}\n\t\t});\n\n\t\t// Given a URI of:  data:image/png;size:2313;label:SomeLabel;description:SomeDescription;base64,77+9UE5...\n\t\t// the mime is: image/png\n\t\tconst mime = dataUri.path.substring(0, dataUri.path.indexOf(';'));\n\t\tif (mime) {\n\t\t\tmetadata.set(META_DATA_MIME, mime);\n\t\t}\n\n\t\treturn metadata;\n\t}\n}\n\nexport function toLocalResource(resource: URI, authority: string | undefined, localScheme: string): URI {\n\tif (authority) {\n\t\tlet path = resource.path;\n\t\tif (path && path[0] !== paths.posix.sep) {\n\t\t\tpath = paths.posix.sep + path;\n\t\t}\n\n\t\treturn resource.with({ scheme: localScheme, authority, path });\n\t}\n\n\treturn resource.with({ scheme: localScheme });\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CancellationToken, CancellationTokenSource } from 'vs/base/common/cancellation';\nimport { CancellationError } from 'vs/base/common/errors';\nimport { Emitter, Event } from 'vs/base/common/event';\nimport { Disposable, IDisposable, MutableDisposable, toDisposable } from 'vs/base/common/lifecycle';\nimport { extUri as defaultExtUri, IExtUri } from 'vs/base/common/resources';\nimport { URI } from 'vs/base/common/uri';\nimport { setTimeout0 } from 'vs/base/common/platform';\nimport { MicrotaskDelay } from './symbols';\n\nexport function isThenable<T>(obj: unknown): obj is Promise<T> {\n\treturn !!obj && typeof (obj as unknown as Promise<T>).then === 'function';\n}\n\nexport interface CancelablePromise<T> extends Promise<T> {\n\tcancel(): void;\n}\n\nexport function createCancelablePromise<T>(callback: (token: CancellationToken) => Promise<T>): CancelablePromise<T> {\n\tconst source = new CancellationTokenSource();\n\n\tconst thenable = callback(source.token);\n\tconst promise = new Promise<T>((resolve, reject) => {\n\t\tconst subscription = source.token.onCancellationRequested(() => {\n\t\t\tsubscription.dispose();\n\t\t\tsource.dispose();\n\t\t\treject(new CancellationError());\n\t\t});\n\t\tPromise.resolve(thenable).then(value => {\n\t\t\tsubscription.dispose();\n\t\t\tsource.dispose();\n\t\t\tresolve(value);\n\t\t}, err => {\n\t\t\tsubscription.dispose();\n\t\t\tsource.dispose();\n\t\t\treject(err);\n\t\t});\n\t});\n\n\treturn <CancelablePromise<T>>new class {\n\t\tcancel() {\n\t\t\tsource.cancel();\n\t\t}\n\t\tthen<TResult1 = T, TResult2 = never>(resolve?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, reject?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2> {\n\t\t\treturn promise.then(resolve, reject);\n\t\t}\n\t\tcatch<TResult = never>(reject?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult> {\n\t\t\treturn this.then(undefined, reject);\n\t\t}\n\t\tfinally(onfinally?: (() => void) | undefined | null): Promise<T> {\n\t\t\treturn promise.finally(onfinally);\n\t\t}\n\t};\n}\n\n/**\n * Returns a promise that resolves with `undefined` as soon as the passed token is cancelled.\n * @see {@link raceCancellationError}\n */\nexport function raceCancellation<T>(promise: Promise<T>, token: CancellationToken): Promise<T | undefined>;\n\n/**\n * Returns a promise that resolves with `defaultValue` as soon as the passed token is cancelled.\n * @see {@link raceCancellationError}\n */\nexport function raceCancellation<T>(promise: Promise<T>, token: CancellationToken, defaultValue: T): Promise<T>;\n\nexport function raceCancellation<T>(promise: Promise<T>, token: CancellationToken, defaultValue?: T): Promise<T | undefined> {\n\treturn new Promise((resolve, reject) => {\n\t\tconst ref = token.onCancellationRequested(() => {\n\t\t\tref.dispose();\n\t\t\tresolve(defaultValue);\n\t\t});\n\t\tpromise.then(resolve, reject).finally(() => ref.dispose());\n\t});\n}\n\n/**\n * Returns a promise that rejects with an {@CancellationError} as soon as the passed token is cancelled.\n * @see {@link raceCancellation}\n */\nexport function raceCancellationError<T>(promise: Promise<T>, token: CancellationToken): Promise<T> {\n\treturn new Promise((resolve, reject) => {\n\t\tconst ref = token.onCancellationRequested(() => {\n\t\t\tref.dispose();\n\t\t\treject(new CancellationError());\n\t\t});\n\t\tpromise.then(resolve, reject).finally(() => ref.dispose());\n\t});\n}\n\n/**\n * Returns as soon as one of the promises is resolved and cancels remaining promises\n */\nexport async function raceCancellablePromises<T>(cancellablePromises: CancelablePromise<T>[]): Promise<T> {\n\tlet resolvedPromiseIndex = -1;\n\tconst promises = cancellablePromises.map((promise, index) => promise.then(result => { resolvedPromiseIndex = index; return result; }));\n\tconst result = await Promise.race(promises);\n\tcancellablePromises.forEach((cancellablePromise, index) => {\n\t\tif (index !== resolvedPromiseIndex) {\n\t\t\tcancellablePromise.cancel();\n\t\t}\n\t});\n\treturn result;\n}\n\nexport function raceTimeout<T>(promise: Promise<T>, timeout: number, onTimeout?: () => void): Promise<T | undefined> {\n\tlet promiseResolve: ((value: T | undefined) => void) | undefined = undefined;\n\n\tconst timer = setTimeout(() => {\n\t\tpromiseResolve?.(undefined);\n\t\tonTimeout?.();\n\t}, timeout);\n\n\treturn Promise.race([\n\t\tpromise.finally(() => clearTimeout(timer)),\n\t\tnew Promise<T | undefined>(resolve => promiseResolve = resolve)\n\t]);\n}\n\nexport function asPromise<T>(callback: () => T | Thenable<T>): Promise<T> {\n\treturn new Promise<T>((resolve, reject) => {\n\t\tconst item = callback();\n\t\tif (isThenable<T>(item)) {\n\t\t\titem.then(resolve, reject);\n\t\t} else {\n\t\t\tresolve(item);\n\t\t}\n\t});\n}\n\nexport interface ITask<T> {\n\t(): T;\n}\n\n/**\n * A helper to prevent accumulation of sequential async tasks.\n *\n * Imagine a mail man with the sole task of delivering letters. As soon as\n * a letter submitted for delivery, he drives to the destination, delivers it\n * and returns to his base. Imagine that during the trip, N more letters were submitted.\n * When the mail man returns, he picks those N letters and delivers them all in a\n * single trip. Even though N+1 submissions occurred, only 2 deliveries were made.\n *\n * The throttler implements this via the queue() method, by providing it a task\n * factory. Following the example:\n *\n * \t\tconst throttler = new Throttler();\n * \t\tconst letters = [];\n *\n * \t\tfunction deliver() {\n * \t\t\tconst lettersToDeliver = letters;\n * \t\t\tletters = [];\n * \t\t\treturn makeTheTrip(lettersToDeliver);\n * \t\t}\n *\n * \t\tfunction onLetterReceived(l) {\n * \t\t\tletters.push(l);\n * \t\t\tthrottler.queue(deliver);\n * \t\t}\n */\nexport class Throttler {\n\n\tprivate activePromise: Promise<any> | null;\n\tprivate queuedPromise: Promise<any> | null;\n\tprivate queuedPromiseFactory: ITask<Promise<any>> | null;\n\n\tconstructor() {\n\t\tthis.activePromise = null;\n\t\tthis.queuedPromise = null;\n\t\tthis.queuedPromiseFactory = null;\n\t}\n\n\tqueue<T>(promiseFactory: ITask<Promise<T>>): Promise<T> {\n\t\tif (this.activePromise) {\n\t\t\tthis.queuedPromiseFactory = promiseFactory;\n\n\t\t\tif (!this.queuedPromise) {\n\t\t\t\tconst onComplete = () => {\n\t\t\t\t\tthis.queuedPromise = null;\n\n\t\t\t\t\tconst result = this.queue(this.queuedPromiseFactory!);\n\t\t\t\t\tthis.queuedPromiseFactory = null;\n\n\t\t\t\t\treturn result;\n\t\t\t\t};\n\n\t\t\t\tthis.queuedPromise = new Promise(resolve => {\n\t\t\t\t\tthis.activePromise!.then(onComplete, onComplete).then(resolve);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn new Promise((resolve, reject) => {\n\t\t\t\tthis.queuedPromise!.then(resolve, reject);\n\t\t\t});\n\t\t}\n\n\t\tthis.activePromise = promiseFactory();\n\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tthis.activePromise!.then((result: T) => {\n\t\t\t\tthis.activePromise = null;\n\t\t\t\tresolve(result);\n\t\t\t}, (err: unknown) => {\n\t\t\t\tthis.activePromise = null;\n\t\t\t\treject(err);\n\t\t\t});\n\t\t});\n\t}\n}\n\nexport class Sequencer {\n\n\tprivate current: Promise<unknown> = Promise.resolve(null);\n\n\tqueue<T>(promiseTask: ITask<Promise<T>>): Promise<T> {\n\t\treturn this.current = this.current.then(() => promiseTask(), () => promiseTask());\n\t}\n}\n\nexport class SequencerByKey<TKey> {\n\n\tprivate promiseMap = new Map<TKey, Promise<unknown>>();\n\n\tqueue<T>(key: TKey, promiseTask: ITask<Promise<T>>): Promise<T> {\n\t\tconst runningPromise = this.promiseMap.get(key) ?? Promise.resolve();\n\t\tconst newPromise = runningPromise\n\t\t\t.catch(() => { })\n\t\t\t.then(promiseTask)\n\t\t\t.finally(() => {\n\t\t\t\tif (this.promiseMap.get(key) === newPromise) {\n\t\t\t\t\tthis.promiseMap.delete(key);\n\t\t\t\t}\n\t\t\t});\n\t\tthis.promiseMap.set(key, newPromise);\n\t\treturn newPromise;\n\t}\n}\n\ninterface IScheduledLater extends IDisposable {\n\tisTriggered(): boolean;\n}\n\nconst timeoutDeferred = (timeout: number, fn: () => void): IScheduledLater => {\n\tlet scheduled = true;\n\tconst handle = setTimeout(() => {\n\t\tscheduled = false;\n\t\tfn();\n\t}, timeout);\n\treturn {\n\t\tisTriggered: () => scheduled,\n\t\tdispose: () => {\n\t\t\tclearTimeout(handle);\n\t\t\tscheduled = false;\n\t\t},\n\t};\n};\n\nconst microtaskDeferred = (fn: () => void): IScheduledLater => {\n\tlet scheduled = true;\n\tqueueMicrotask(() => {\n\t\tif (scheduled) {\n\t\t\tscheduled = false;\n\t\t\tfn();\n\t\t}\n\t});\n\n\treturn {\n\t\tisTriggered: () => scheduled,\n\t\tdispose: () => { scheduled = false; },\n\t};\n};\n\n/**\n * A helper to delay (debounce) execution of a task that is being requested often.\n *\n * Following the throttler, now imagine the mail man wants to optimize the number of\n * trips proactively. The trip itself can be long, so he decides not to make the trip\n * as soon as a letter is submitted. Instead he waits a while, in case more\n * letters are submitted. After said waiting period, if no letters were submitted, he\n * decides to make the trip. Imagine that N more letters were submitted after the first\n * one, all within a short period of time between each other. Even though N+1\n * submissions occurred, only 1 delivery was made.\n *\n * The delayer offers this behavior via the trigger() method, into which both the task\n * to be executed and the waiting period (delay) must be passed in as arguments. Following\n * the example:\n *\n * \t\tconst delayer = new Delayer(WAITING_PERIOD);\n * \t\tconst letters = [];\n *\n * \t\tfunction letterReceived(l) {\n * \t\t\tletters.push(l);\n * \t\t\tdelayer.trigger(() => { return makeTheTrip(); });\n * \t\t}\n */\nexport class Delayer<T> implements IDisposable {\n\n\tprivate deferred: IScheduledLater | null;\n\tprivate completionPromise: Promise<any> | null;\n\tprivate doResolve: ((value?: any | Promise<any>) => void) | null;\n\tprivate doReject: ((err: any) => void) | null;\n\tprivate task: ITask<T | Promise<T>> | null;\n\n\tconstructor(public defaultDelay: number | typeof MicrotaskDelay) {\n\t\tthis.deferred = null;\n\t\tthis.completionPromise = null;\n\t\tthis.doResolve = null;\n\t\tthis.doReject = null;\n\t\tthis.task = null;\n\t}\n\n\ttrigger(task: ITask<T | Promise<T>>, delay = this.defaultDelay): Promise<T> {\n\t\tthis.task = task;\n\t\tthis.cancelTimeout();\n\n\t\tif (!this.completionPromise) {\n\t\t\tthis.completionPromise = new Promise((resolve, reject) => {\n\t\t\t\tthis.doResolve = resolve;\n\t\t\t\tthis.doReject = reject;\n\t\t\t}).then(() => {\n\t\t\t\tthis.completionPromise = null;\n\t\t\t\tthis.doResolve = null;\n\t\t\t\tif (this.task) {\n\t\t\t\t\tconst task = this.task;\n\t\t\t\t\tthis.task = null;\n\t\t\t\t\treturn task();\n\t\t\t\t}\n\t\t\t\treturn undefined;\n\t\t\t});\n\t\t}\n\n\t\tconst fn = () => {\n\t\t\tthis.deferred = null;\n\t\t\tthis.doResolve?.(null);\n\t\t};\n\n\t\tthis.deferred = delay === MicrotaskDelay ? microtaskDeferred(fn) : timeoutDeferred(delay, fn);\n\n\t\treturn this.completionPromise;\n\t}\n\n\tisTriggered(): boolean {\n\t\treturn !!this.deferred?.isTriggered();\n\t}\n\n\tcancel(): void {\n\t\tthis.cancelTimeout();\n\n\t\tif (this.completionPromise) {\n\t\t\tthis.doReject?.(new CancellationError());\n\t\t\tthis.completionPromise = null;\n\t\t}\n\t}\n\n\tprivate cancelTimeout(): void {\n\t\tthis.deferred?.dispose();\n\t\tthis.deferred = null;\n\t}\n\n\tdispose(): void {\n\t\tthis.cancel();\n\t}\n}\n\n/**\n * A helper to delay execution of a task that is being requested often, while\n * preventing accumulation of consecutive executions, while the task runs.\n *\n * The mail man is clever and waits for a certain amount of time, before going\n * out to deliver letters. While the mail man is going out, more letters arrive\n * and can only be delivered once he is back. Once he is back the mail man will\n * do one more trip to deliver the letters that have accumulated while he was out.\n */\nexport class ThrottledDelayer<T> {\n\n\tprivate delayer: Delayer<Promise<T>>;\n\tprivate throttler: Throttler;\n\n\tconstructor(defaultDelay: number) {\n\t\tthis.delayer = new Delayer(defaultDelay);\n\t\tthis.throttler = new Throttler();\n\t}\n\n\ttrigger(promiseFactory: ITask<Promise<T>>, delay?: number): Promise<T> {\n\t\treturn this.delayer.trigger(() => this.throttler.queue(promiseFactory), delay) as unknown as Promise<T>;\n\t}\n\n\tisTriggered(): boolean {\n\t\treturn this.delayer.isTriggered();\n\t}\n\n\tcancel(): void {\n\t\tthis.delayer.cancel();\n\t}\n\n\tdispose(): void {\n\t\tthis.delayer.dispose();\n\t}\n}\n\n/**\n * A barrier that is initially closed and then becomes opened permanently.\n */\nexport class Barrier {\n\n\tprivate _isOpen: boolean;\n\tprivate _promise: Promise<boolean>;\n\tprivate _completePromise!: (v: boolean) => void;\n\n\tconstructor() {\n\t\tthis._isOpen = false;\n\t\tthis._promise = new Promise<boolean>((c, e) => {\n\t\t\tthis._completePromise = c;\n\t\t});\n\t}\n\n\tisOpen(): boolean {\n\t\treturn this._isOpen;\n\t}\n\n\topen(): void {\n\t\tthis._isOpen = true;\n\t\tthis._completePromise(true);\n\t}\n\n\twait(): Promise<boolean> {\n\t\treturn this._promise;\n\t}\n}\n\n/**\n * A barrier that is initially closed and then becomes opened permanently after a certain period of\n * time or when open is called explicitly\n */\nexport class AutoOpenBarrier extends Barrier {\n\n\tprivate readonly _timeout: any;\n\n\tconstructor(autoOpenTimeMs: number) {\n\t\tsuper();\n\t\tthis._timeout = setTimeout(() => this.open(), autoOpenTimeMs);\n\t}\n\n\toverride open(): void {\n\t\tclearTimeout(this._timeout);\n\t\tsuper.open();\n\t}\n}\n\nexport function timeout(millis: number): CancelablePromise<void>;\nexport function timeout(millis: number, token: CancellationToken): Promise<void>;\nexport function timeout(millis: number, token?: CancellationToken): CancelablePromise<void> | Promise<void> {\n\tif (!token) {\n\t\treturn createCancelablePromise(token => timeout(millis, token));\n\t}\n\n\treturn new Promise((resolve, reject) => {\n\t\tconst handle = setTimeout(() => {\n\t\t\tdisposable.dispose();\n\t\t\tresolve();\n\t\t}, millis);\n\t\tconst disposable = token.onCancellationRequested(() => {\n\t\t\tclearTimeout(handle);\n\t\t\tdisposable.dispose();\n\t\t\treject(new CancellationError());\n\t\t});\n\t});\n}\n\nexport function disposableTimeout(handler: () => void, timeout = 0): IDisposable {\n\tconst timer = setTimeout(handler, timeout);\n\treturn toDisposable(() => clearTimeout(timer));\n}\n\n/**\n * Runs the provided list of promise factories in sequential order. The returned\n * promise will complete to an array of results from each promise.\n */\n\nexport function sequence<T>(promiseFactories: ITask<Promise<T>>[]): Promise<T[]> {\n\tconst results: T[] = [];\n\tlet index = 0;\n\tconst len = promiseFactories.length;\n\n\tfunction next(): Promise<T> | null {\n\t\treturn index < len ? promiseFactories[index++]() : null;\n\t}\n\n\tfunction thenHandler(result: any): Promise<any> {\n\t\tif (result !== undefined && result !== null) {\n\t\t\tresults.push(result);\n\t\t}\n\n\t\tconst n = next();\n\t\tif (n) {\n\t\t\treturn n.then(thenHandler);\n\t\t}\n\n\t\treturn Promise.resolve(results);\n\t}\n\n\treturn Promise.resolve(null).then(thenHandler);\n}\n\nexport function first<T>(promiseFactories: ITask<Promise<T>>[], shouldStop: (t: T) => boolean = t => !!t, defaultValue: T | null = null): Promise<T | null> {\n\tlet index = 0;\n\tconst len = promiseFactories.length;\n\n\tconst loop: () => Promise<T | null> = () => {\n\t\tif (index >= len) {\n\t\t\treturn Promise.resolve(defaultValue);\n\t\t}\n\n\t\tconst factory = promiseFactories[index++];\n\t\tconst promise = Promise.resolve(factory());\n\n\t\treturn promise.then(result => {\n\t\t\tif (shouldStop(result)) {\n\t\t\t\treturn Promise.resolve(result);\n\t\t\t}\n\n\t\t\treturn loop();\n\t\t});\n\t};\n\n\treturn loop();\n}\n\n/**\n * Returns the result of the first promise that matches the \"shouldStop\",\n * running all promises in parallel. Supports cancelable promises.\n */\nexport function firstParallel<T>(promiseList: Promise<T>[], shouldStop?: (t: T) => boolean, defaultValue?: T | null): Promise<T | null>;\nexport function firstParallel<T, R extends T>(promiseList: Promise<T>[], shouldStop: (t: T) => t is R, defaultValue?: R | null): Promise<R | null>;\nexport function firstParallel<T>(promiseList: Promise<T>[], shouldStop: (t: T) => boolean = t => !!t, defaultValue: T | null = null) {\n\tif (promiseList.length === 0) {\n\t\treturn Promise.resolve(defaultValue);\n\t}\n\n\tlet todo = promiseList.length;\n\tconst finish = () => {\n\t\ttodo = -1;\n\t\tfor (const promise of promiseList) {\n\t\t\t(promise as Partial<CancelablePromise<T>>).cancel?.();\n\t\t}\n\t};\n\n\treturn new Promise<T | null>((resolve, reject) => {\n\t\tfor (const promise of promiseList) {\n\t\t\tpromise.then(result => {\n\t\t\t\tif (--todo >= 0 && shouldStop(result)) {\n\t\t\t\t\tfinish();\n\t\t\t\t\tresolve(result);\n\t\t\t\t} else if (todo === 0) {\n\t\t\t\t\tresolve(defaultValue);\n\t\t\t\t}\n\t\t\t})\n\t\t\t\t.catch(err => {\n\t\t\t\t\tif (--todo >= 0) {\n\t\t\t\t\t\tfinish();\n\t\t\t\t\t\treject(err);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t}\n\t});\n}\n\ninterface ILimitedTaskFactory<T> {\n\tfactory: ITask<Promise<T>>;\n\tc: (value: T | Promise<T>) => void;\n\te: (error?: unknown) => void;\n}\n\nexport interface ILimiter<T> {\n\n\treadonly size: number;\n\n\tqueue(factory: ITask<Promise<T>>): Promise<T>;\n}\n\n/**\n * A helper to queue N promises and run them all with a max degree of parallelism. The helper\n * ensures that at any time no more than M promises are running at the same time.\n */\nexport class Limiter<T> implements ILimiter<T>{\n\n\tprivate _size = 0;\n\tprivate runningPromises: number;\n\tprivate readonly maxDegreeOfParalellism: number;\n\tprivate readonly outstandingPromises: ILimitedTaskFactory<T>[];\n\tprivate readonly _onDrained: Emitter<void>;\n\n\tconstructor(maxDegreeOfParalellism: number) {\n\t\tthis.maxDegreeOfParalellism = maxDegreeOfParalellism;\n\t\tthis.outstandingPromises = [];\n\t\tthis.runningPromises = 0;\n\t\tthis._onDrained = new Emitter<void>();\n\t}\n\n\t/**\n\t * An event that fires when every promise in the queue\n\t * has started to execute. In other words: no work is\n\t * pending to be scheduled.\n\t *\n\t * This is NOT an event that signals when all promises\n\t * have finished though.\n\t */\n\tget onDrained(): Event<void> {\n\t\treturn this._onDrained.event;\n\t}\n\n\tget size(): number {\n\t\treturn this._size;\n\t}\n\n\tqueue(factory: ITask<Promise<T>>): Promise<T> {\n\t\tthis._size++;\n\n\t\treturn new Promise<T>((c, e) => {\n\t\t\tthis.outstandingPromises.push({ factory, c, e });\n\t\t\tthis.consume();\n\t\t});\n\t}\n\n\tprivate consume(): void {\n\t\twhile (this.outstandingPromises.length && this.runningPromises < this.maxDegreeOfParalellism) {\n\t\t\tconst iLimitedTask = this.outstandingPromises.shift()!;\n\t\t\tthis.runningPromises++;\n\n\t\t\tconst promise = iLimitedTask.factory();\n\t\t\tpromise.then(iLimitedTask.c, iLimitedTask.e);\n\t\t\tpromise.then(() => this.consumed(), () => this.consumed());\n\t\t}\n\t}\n\n\tprivate consumed(): void {\n\t\tthis._size--;\n\t\tthis.runningPromises--;\n\n\t\tif (this.outstandingPromises.length > 0) {\n\t\t\tthis.consume();\n\t\t} else {\n\t\t\tthis._onDrained.fire();\n\t\t}\n\t}\n\n\tdispose(): void {\n\t\tthis._onDrained.dispose();\n\t}\n}\n\n/**\n * A queue is handles one promise at a time and guarantees that at any time only one promise is executing.\n */\nexport class Queue<T> extends Limiter<T> {\n\n\tconstructor() {\n\t\tsuper(1);\n\t}\n}\n\n/**\n * A helper to organize queues per resource. The ResourceQueue makes sure to manage queues per resource\n * by disposing them once the queue is empty.\n */\nexport class ResourceQueue implements IDisposable {\n\n\tprivate readonly queues = new Map<string, Queue<void>>();\n\n\tprivate readonly drainers = new Set<DeferredPromise<void>>();\n\n\tasync whenDrained(): Promise<void> {\n\t\tif (this.isDrained()) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst promise = new DeferredPromise<void>();\n\t\tthis.drainers.add(promise);\n\n\t\treturn promise.p;\n\t}\n\n\tprivate isDrained(): boolean {\n\t\tfor (const [, queue] of this.queues) {\n\t\t\tif (queue.size > 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tqueueFor(resource: URI, extUri: IExtUri = defaultExtUri): ILimiter<void> {\n\t\tconst key = extUri.getComparisonKey(resource);\n\n\t\tlet queue = this.queues.get(key);\n\t\tif (!queue) {\n\t\t\tqueue = new Queue<void>();\n\t\t\tEvent.once(queue.onDrained)(() => {\n\t\t\t\tqueue?.dispose();\n\t\t\t\tthis.queues.delete(key);\n\t\t\t\tthis.onDidQueueDrain();\n\t\t\t});\n\n\t\t\tthis.queues.set(key, queue);\n\t\t}\n\n\t\treturn queue;\n\t}\n\n\tprivate onDidQueueDrain(): void {\n\t\tif (!this.isDrained()) {\n\t\t\treturn; // not done yet\n\t\t}\n\n\t\tthis.releaseDrainers();\n\t}\n\n\tprivate releaseDrainers(): void {\n\t\tfor (const drainer of this.drainers) {\n\t\t\tdrainer.complete();\n\t\t}\n\n\t\tthis.drainers.clear();\n\t}\n\n\tdispose(): void {\n\t\tfor (const [, queue] of this.queues) {\n\t\t\tqueue.dispose();\n\t\t}\n\n\t\tthis.queues.clear();\n\n\t\t// Even though we might still have pending\n\t\t// tasks queued, after the queues have been\n\t\t// disposed, we can no longer track them, so\n\t\t// we release drainers to prevent hanging\n\t\t// promises when the resource queue is being\n\t\t// disposed.\n\t\tthis.releaseDrainers();\n\t}\n}\n\nexport class TimeoutTimer implements IDisposable {\n\tprivate _token: any;\n\n\tconstructor();\n\tconstructor(runner: () => void, timeout: number);\n\tconstructor(runner?: () => void, timeout?: number) {\n\t\tthis._token = -1;\n\n\t\tif (typeof runner === 'function' && typeof timeout === 'number') {\n\t\t\tthis.setIfNotSet(runner, timeout);\n\t\t}\n\t}\n\n\tdispose(): void {\n\t\tthis.cancel();\n\t}\n\n\tcancel(): void {\n\t\tif (this._token !== -1) {\n\t\t\tclearTimeout(this._token);\n\t\t\tthis._token = -1;\n\t\t}\n\t}\n\n\tcancelAndSet(runner: () => void, timeout: number): void {\n\t\tthis.cancel();\n\t\tthis._token = setTimeout(() => {\n\t\t\tthis._token = -1;\n\t\t\trunner();\n\t\t}, timeout);\n\t}\n\n\tsetIfNotSet(runner: () => void, timeout: number): void {\n\t\tif (this._token !== -1) {\n\t\t\t// timer is already set\n\t\t\treturn;\n\t\t}\n\t\tthis._token = setTimeout(() => {\n\t\t\tthis._token = -1;\n\t\t\trunner();\n\t\t}, timeout);\n\t}\n}\n\nexport class IntervalTimer implements IDisposable {\n\n\tprivate _token: any;\n\n\tconstructor() {\n\t\tthis._token = -1;\n\t}\n\n\tdispose(): void {\n\t\tthis.cancel();\n\t}\n\n\tcancel(): void {\n\t\tif (this._token !== -1) {\n\t\t\tclearInterval(this._token);\n\t\t\tthis._token = -1;\n\t\t}\n\t}\n\n\tcancelAndSet(runner: () => void, interval: number): void {\n\t\tthis.cancel();\n\t\tthis._token = setInterval(() => {\n\t\t\trunner();\n\t\t}, interval);\n\t}\n}\n\nexport class RunOnceScheduler implements IDisposable {\n\n\tprotected runner: ((...args: unknown[]) => void) | null;\n\n\tprivate timeoutToken: any;\n\tprivate timeout: number;\n\tprivate timeoutHandler: () => void;\n\n\tconstructor(runner: (...args: any[]) => void, delay: number) {\n\t\tthis.timeoutToken = -1;\n\t\tthis.runner = runner;\n\t\tthis.timeout = delay;\n\t\tthis.timeoutHandler = this.onTimeout.bind(this);\n\t}\n\n\t/**\n\t * Dispose RunOnceScheduler\n\t */\n\tdispose(): void {\n\t\tthis.cancel();\n\t\tthis.runner = null;\n\t}\n\n\t/**\n\t * Cancel current scheduled runner (if any).\n\t */\n\tcancel(): void {\n\t\tif (this.isScheduled()) {\n\t\t\tclearTimeout(this.timeoutToken);\n\t\t\tthis.timeoutToken = -1;\n\t\t}\n\t}\n\n\t/**\n\t * Cancel previous runner (if any) & schedule a new runner.\n\t */\n\tschedule(delay = this.timeout): void {\n\t\tthis.cancel();\n\t\tthis.timeoutToken = setTimeout(this.timeoutHandler, delay);\n\t}\n\n\tget delay(): number {\n\t\treturn this.timeout;\n\t}\n\n\tset delay(value: number) {\n\t\tthis.timeout = value;\n\t}\n\n\t/**\n\t * Returns true if scheduled.\n\t */\n\tisScheduled(): boolean {\n\t\treturn this.timeoutToken !== -1;\n\t}\n\n\tflush(): void {\n\t\tif (this.isScheduled()) {\n\t\t\tthis.cancel();\n\t\t\tthis.doRun();\n\t\t}\n\t}\n\n\tprivate onTimeout() {\n\t\tthis.timeoutToken = -1;\n\t\tif (this.runner) {\n\t\t\tthis.doRun();\n\t\t}\n\t}\n\n\tprotected doRun(): void {\n\t\tthis.runner?.();\n\t}\n}\n\n/**\n * Same as `RunOnceScheduler`, but doesn't count the time spent in sleep mode.\n * > **NOTE**: Only offers 1s resolution.\n *\n * When calling `setTimeout` with 3hrs, and putting the computer immediately to sleep\n * for 8hrs, `setTimeout` will fire **as soon as the computer wakes from sleep**. But\n * this scheduler will execute 3hrs **after waking the computer from sleep**.\n */\nexport class ProcessTimeRunOnceScheduler {\n\n\tprivate runner: (() => void) | null;\n\tprivate timeout: number;\n\n\tprivate counter: number;\n\tprivate intervalToken: any;\n\tprivate intervalHandler: () => void;\n\n\tconstructor(runner: () => void, delay: number) {\n\t\tif (delay % 1000 !== 0) {\n\t\t\tconsole.warn(`ProcessTimeRunOnceScheduler resolution is 1s, ${delay}ms is not a multiple of 1000ms.`);\n\t\t}\n\t\tthis.runner = runner;\n\t\tthis.timeout = delay;\n\t\tthis.counter = 0;\n\t\tthis.intervalToken = -1;\n\t\tthis.intervalHandler = this.onInterval.bind(this);\n\t}\n\n\tdispose(): void {\n\t\tthis.cancel();\n\t\tthis.runner = null;\n\t}\n\n\tcancel(): void {\n\t\tif (this.isScheduled()) {\n\t\t\tclearInterval(this.intervalToken);\n\t\t\tthis.intervalToken = -1;\n\t\t}\n\t}\n\n\t/**\n\t * Cancel previous runner (if any) & schedule a new runner.\n\t */\n\tschedule(delay = this.timeout): void {\n\t\tif (delay % 1000 !== 0) {\n\t\t\tconsole.warn(`ProcessTimeRunOnceScheduler resolution is 1s, ${delay}ms is not a multiple of 1000ms.`);\n\t\t}\n\t\tthis.cancel();\n\t\tthis.counter = Math.ceil(delay / 1000);\n\t\tthis.intervalToken = setInterval(this.intervalHandler, 1000);\n\t}\n\n\t/**\n\t * Returns true if scheduled.\n\t */\n\tisScheduled(): boolean {\n\t\treturn this.intervalToken !== -1;\n\t}\n\n\tprivate onInterval() {\n\t\tthis.counter--;\n\t\tif (this.counter > 0) {\n\t\t\t// still need to wait\n\t\t\treturn;\n\t\t}\n\n\t\t// time elapsed\n\t\tclearInterval(this.intervalToken);\n\t\tthis.intervalToken = -1;\n\t\tthis.runner?.();\n\t}\n}\n\nexport class RunOnceWorker<T> extends RunOnceScheduler {\n\n\tprivate units: T[] = [];\n\n\tconstructor(runner: (units: T[]) => void, timeout: number) {\n\t\tsuper(runner, timeout);\n\t}\n\n\twork(unit: T): void {\n\t\tthis.units.push(unit);\n\n\t\tif (!this.isScheduled()) {\n\t\t\tthis.schedule();\n\t\t}\n\t}\n\n\tprotected override doRun(): void {\n\t\tconst units = this.units;\n\t\tthis.units = [];\n\n\t\tthis.runner?.(units);\n\t}\n\n\toverride dispose(): void {\n\t\tthis.units = [];\n\n\t\tsuper.dispose();\n\t}\n}\n\nexport interface IThrottledWorkerOptions {\n\n\t/**\n\t * maximum of units the worker will pass onto handler at once\n\t */\n\tmaxWorkChunkSize: number;\n\n\t/**\n\t * maximum of units the worker will keep in memory for processing\n\t */\n\tmaxBufferedWork: number | undefined;\n\n\t/**\n\t * delay before processing the next round of chunks when chunk size exceeds limits\n\t */\n\tthrottleDelay: number;\n}\n\n/**\n * The `ThrottledWorker` will accept units of work `T`\n * to handle. The contract is:\n * * there is a maximum of units the worker can handle at once (via `maxWorkChunkSize`)\n * * there is a maximum of units the worker will keep in memory for processing (via `maxBufferedWork`)\n * * after having handled `maxWorkChunkSize` units, the worker needs to rest (via `throttleDelay`)\n */\nexport class ThrottledWorker<T> extends Disposable {\n\n\tprivate readonly pendingWork: T[] = [];\n\n\tprivate readonly throttler = this._register(new MutableDisposable<RunOnceScheduler>());\n\tprivate disposed = false;\n\n\tconstructor(\n\t\tprivate options: IThrottledWorkerOptions,\n\t\tprivate readonly handler: (units: T[]) => void\n\t) {\n\t\tsuper();\n\t}\n\n\t/**\n\t * The number of work units that are pending to be processed.\n\t */\n\tget pending(): number { return this.pendingWork.length; }\n\n\t/**\n\t * Add units to be worked on. Use `pending` to figure out\n\t * how many units are not yet processed after this method\n\t * was called.\n\t *\n\t * @returns whether the work was accepted or not. If the\n\t * worker is disposed, it will not accept any more work.\n\t * If the number of pending units would become larger\n\t * than `maxPendingWork`, more work will also not be accepted.\n\t */\n\twork(units: readonly T[]): boolean {\n\t\tif (this.disposed) {\n\t\t\treturn false; // work not accepted: disposed\n\t\t}\n\n\t\t// Check for reaching maximum of pending work\n\t\tif (typeof this.options.maxBufferedWork === 'number') {\n\n\t\t\t// Throttled: simple check if pending + units exceeds max pending\n\t\t\tif (this.throttler.value) {\n\t\t\t\tif (this.pending + units.length > this.options.maxBufferedWork) {\n\t\t\t\t\treturn false; // work not accepted: too much pending work\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Unthrottled: same as throttled, but account for max chunk getting\n\t\t\t// worked on directly without being pending\n\t\t\telse {\n\t\t\t\tif (this.pending + units.length - this.options.maxWorkChunkSize > this.options.maxBufferedWork) {\n\t\t\t\t\treturn false; // work not accepted: too much pending work\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Add to pending units first\n\t\tfor (const unit of units) {\n\t\t\tthis.pendingWork.push(unit);\n\t\t}\n\n\t\t// If not throttled, start working directly\n\t\t// Otherwise, when the throttle delay has\n\t\t// past, pending work will be worked again.\n\t\tif (!this.throttler.value) {\n\t\t\tthis.doWork();\n\t\t}\n\n\t\treturn true; // work accepted\n\t}\n\n\tprivate doWork(): void {\n\n\t\t// Extract chunk to handle and handle it\n\t\tthis.handler(this.pendingWork.splice(0, this.options.maxWorkChunkSize));\n\n\t\t// If we have remaining work, schedule it after a delay\n\t\tif (this.pendingWork.length > 0) {\n\t\t\tthis.throttler.value = new RunOnceScheduler(() => {\n\t\t\t\tthis.throttler.clear();\n\n\t\t\t\tthis.doWork();\n\t\t\t}, this.options.throttleDelay);\n\t\t\tthis.throttler.value.schedule();\n\t\t}\n\t}\n\n\toverride dispose(): void {\n\t\tsuper.dispose();\n\n\t\tthis.disposed = true;\n\t}\n}\n\n//#region -- run on idle tricks ------------\n\nexport interface IdleDeadline {\n\treadonly didTimeout: boolean;\n\ttimeRemaining(): number;\n}\n\n/**\n * Execute the callback the next time the browser is idle, returning an\n * {@link IDisposable} that will cancel the callback when disposed. This wraps\n * [requestIdleCallback] so it will fallback to [setTimeout] if the environment\n * doesn't support it.\n *\n * @param callback The callback to run when idle, this includes an\n * [IdleDeadline] that provides the time alloted for the idle callback by the\n * browser. Not respecting this deadline will result in a degraded user\n * experience.\n * @param timeout A timeout at which point to queue no longer wait for an idle\n * callback but queue it on the regular event loop (like setTimeout). Typically\n * this should not be used.\n *\n * [IdleDeadline]: https://developer.mozilla.org/en-US/docs/Web/API/IdleDeadline\n * [requestIdleCallback]: https://developer.mozilla.org/en-US/docs/Web/API/Window/requestIdleCallback\n * [setTimeout]: https://developer.mozilla.org/en-US/docs/Web/API/Window/setTimeout\n */\nexport let runWhenIdle: (callback: (idle: IdleDeadline) => void, timeout?: number) => IDisposable;\n\ndeclare function requestIdleCallback(callback: (args: IdleDeadline) => void, options?: { timeout: number }): number;\ndeclare function cancelIdleCallback(handle: number): void;\n\n(function () {\n\tif (typeof requestIdleCallback !== 'function' || typeof cancelIdleCallback !== 'function') {\n\t\trunWhenIdle = (runner) => {\n\t\t\tsetTimeout0(() => {\n\t\t\t\tif (disposed) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tconst end = Date.now() + 15; // one frame at 64fps\n\t\t\t\trunner(Object.freeze({\n\t\t\t\t\tdidTimeout: true,\n\t\t\t\t\ttimeRemaining() {\n\t\t\t\t\t\treturn Math.max(0, end - Date.now());\n\t\t\t\t\t}\n\t\t\t\t}));\n\t\t\t});\n\t\t\tlet disposed = false;\n\t\t\treturn {\n\t\t\t\tdispose() {\n\t\t\t\t\tif (disposed) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tdisposed = true;\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\t} else {\n\t\trunWhenIdle = (runner, timeout?) => {\n\t\t\tconst handle: number = requestIdleCallback(runner, typeof timeout === 'number' ? { timeout } : undefined);\n\t\t\tlet disposed = false;\n\t\t\treturn {\n\t\t\t\tdispose() {\n\t\t\t\t\tif (disposed) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tdisposed = true;\n\t\t\t\t\tcancelIdleCallback(handle);\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\t}\n})();\n\n/**\n * An implementation of the \"idle-until-urgent\"-strategy as introduced\n * here: https://philipwalton.com/articles/idle-until-urgent/\n */\nexport class IdleValue<T> {\n\n\tprivate readonly _executor: () => void;\n\tprivate readonly _handle: IDisposable;\n\n\tprivate _didRun: boolean = false;\n\tprivate _value?: T;\n\tprivate _error: unknown;\n\n\tconstructor(executor: () => T) {\n\t\tthis._executor = () => {\n\t\t\ttry {\n\t\t\t\tthis._value = executor();\n\t\t\t} catch (err) {\n\t\t\t\tthis._error = err;\n\t\t\t} finally {\n\t\t\t\tthis._didRun = true;\n\t\t\t}\n\t\t};\n\t\tthis._handle = runWhenIdle(() => this._executor());\n\t}\n\n\tdispose(): void {\n\t\tthis._handle.dispose();\n\t}\n\n\tget value(): T {\n\t\tif (!this._didRun) {\n\t\t\tthis._handle.dispose();\n\t\t\tthis._executor();\n\t\t}\n\t\tif (this._error) {\n\t\t\tthrow this._error;\n\t\t}\n\t\treturn this._value!;\n\t}\n\n\tget isInitialized(): boolean {\n\t\treturn this._didRun;\n\t}\n}\n\n//#endregion\n\nexport async function retry<T>(task: ITask<Promise<T>>, delay: number, retries: number): Promise<T> {\n\tlet lastError: Error | undefined;\n\n\tfor (let i = 0; i < retries; i++) {\n\t\ttry {\n\t\t\treturn await task();\n\t\t} catch (error) {\n\t\t\tlastError = error;\n\n\t\t\tawait timeout(delay);\n\t\t}\n\t}\n\n\tthrow lastError;\n}\n\n//#region Task Sequentializer\n\ninterface IPendingTask {\n\treadonly taskId: number;\n\treadonly cancel: () => void;\n\treadonly promise: Promise<void>;\n}\n\ninterface INextTask {\n\treadonly promise: Promise<void>;\n\treadonly promiseResolve: () => void;\n\treadonly promiseReject: (error: Error) => void;\n\trun: () => Promise<void>;\n}\n\nexport interface ITaskSequentializerWithPendingTask {\n\treadonly pending: Promise<void>;\n}\n\nexport interface ITaskSequentializerWithNextTask {\n\treadonly next: INextTask;\n}\n\nexport class TaskSequentializer {\n\n\tprivate _pending?: IPendingTask;\n\tprivate _next?: INextTask;\n\n\thasPending(taskId?: number): this is ITaskSequentializerWithPendingTask {\n\t\tif (!this._pending) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (typeof taskId === 'number') {\n\t\t\treturn this._pending.taskId === taskId;\n\t\t}\n\n\t\treturn !!this._pending;\n\t}\n\n\tget pending(): Promise<void> | undefined {\n\t\treturn this._pending?.promise;\n\t}\n\n\tcancelPending(): void {\n\t\tthis._pending?.cancel();\n\t}\n\n\tsetPending(taskId: number, promise: Promise<void>, onCancel?: () => void,): Promise<void> {\n\t\tthis._pending = { taskId, cancel: () => onCancel?.(), promise };\n\n\t\tpromise.then(() => this.donePending(taskId), () => this.donePending(taskId));\n\n\t\treturn promise;\n\t}\n\n\tprivate donePending(taskId: number): void {\n\t\tif (this._pending && taskId === this._pending.taskId) {\n\n\t\t\t// only set pending to done if the promise finished that is associated with that taskId\n\t\t\tthis._pending = undefined;\n\n\t\t\t// schedule the next task now that we are free if we have any\n\t\t\tthis.triggerNext();\n\t\t}\n\t}\n\n\tprivate triggerNext(): void {\n\t\tif (this._next) {\n\t\t\tconst next = this._next;\n\t\t\tthis._next = undefined;\n\n\t\t\t// Run next task and complete on the associated promise\n\t\t\tnext.run().then(next.promiseResolve, next.promiseReject);\n\t\t}\n\t}\n\n\tsetNext(run: () => Promise<void>): Promise<void> {\n\n\t\t// this is our first next task, so we create associated promise with it\n\t\t// so that we can return a promise that completes when the task has\n\t\t// completed.\n\t\tif (!this._next) {\n\t\t\tlet promiseResolve: () => void;\n\t\t\tlet promiseReject: (error: Error) => void;\n\t\t\tconst promise = new Promise<void>((resolve, reject) => {\n\t\t\t\tpromiseResolve = resolve;\n\t\t\t\tpromiseReject = reject;\n\t\t\t});\n\n\t\t\tthis._next = {\n\t\t\t\trun,\n\t\t\t\tpromise,\n\t\t\t\tpromiseResolve: promiseResolve!,\n\t\t\t\tpromiseReject: promiseReject!\n\t\t\t};\n\t\t}\n\n\t\t// we have a previous next task, just overwrite it\n\t\telse {\n\t\t\tthis._next.run = run;\n\t\t}\n\n\t\treturn this._next.promise;\n\t}\n\n\thasNext(): this is ITaskSequentializerWithNextTask {\n\t\treturn !!this._next;\n\t}\n\n\tasync join(): Promise<void> {\n\t\treturn this._next?.promise ?? this._pending?.promise;\n\t}\n}\n\n//#endregion\n\n//#region\n\n/**\n * The `IntervalCounter` allows to count the number\n * of calls to `increment()` over a duration of\n * `interval`. This utility can be used to conditionally\n * throttle a frequent task when a certain threshold\n * is reached.\n */\nexport class IntervalCounter {\n\n\tprivate lastIncrementTime = 0;\n\n\tprivate value = 0;\n\n\tconstructor(private readonly interval: number, private readonly nowFn = () => Date.now()) { }\n\n\tincrement(): number {\n\t\tconst now = this.nowFn();\n\n\t\t// We are outside of the range of `interval` and as such\n\t\t// start counting from 0 and remember the time\n\t\tif (now - this.lastIncrementTime > this.interval) {\n\t\t\tthis.lastIncrementTime = now;\n\t\t\tthis.value = 0;\n\t\t}\n\n\t\tthis.value++;\n\n\t\treturn this.value;\n\t}\n}\n\n//#endregion\n\n//#region\n\nexport type ValueCallback<T = unknown> = (value: T | Promise<T>) => void;\n\n/**\n * Creates a promise whose resolution or rejection can be controlled imperatively.\n */\nexport class DeferredPromise<T> {\n\n\tprivate completeCallback!: ValueCallback<T>;\n\tprivate errorCallback!: (err: unknown) => void;\n\tprivate rejected = false;\n\tprivate resolved = false;\n\n\tpublic get isRejected() {\n\t\treturn this.rejected;\n\t}\n\n\tpublic get isResolved() {\n\t\treturn this.resolved;\n\t}\n\n\tpublic get isSettled() {\n\t\treturn this.rejected || this.resolved;\n\t}\n\n\tpublic readonly p: Promise<T>;\n\n\tconstructor() {\n\t\tthis.p = new Promise<T>((c, e) => {\n\t\t\tthis.completeCallback = c;\n\t\t\tthis.errorCallback = e;\n\t\t});\n\t}\n\n\tpublic complete(value: T) {\n\t\treturn new Promise<void>(resolve => {\n\t\t\tthis.completeCallback(value);\n\t\t\tthis.resolved = true;\n\t\t\tresolve();\n\t\t});\n\t}\n\n\tpublic error(err: unknown) {\n\t\treturn new Promise<void>(resolve => {\n\t\t\tthis.errorCallback(err);\n\t\t\tthis.rejected = true;\n\t\t\tresolve();\n\t\t});\n\t}\n\n\tpublic cancel() {\n\t\tnew Promise<void>(resolve => {\n\t\t\tthis.errorCallback(new CancellationError());\n\t\t\tthis.rejected = true;\n\t\t\tresolve();\n\t\t});\n\t}\n}\n\n//#endregion\n\n//#region Promises\n\nexport namespace Promises {\n\n\t/**\n\t * A drop-in replacement for `Promise.all` with the only difference\n\t * that the method awaits every promise to either fulfill or reject.\n\t *\n\t * Similar to `Promise.all`, only the first error will be returned\n\t * if any.\n\t */\n\texport async function settled<T>(promises: Promise<T>[]): Promise<T[]> {\n\t\tlet firstError: Error | undefined = undefined;\n\n\t\tconst result = await Promise.all(promises.map(promise => promise.then(value => value, error => {\n\t\t\tif (!firstError) {\n\t\t\t\tfirstError = error;\n\t\t\t}\n\n\t\t\treturn undefined; // do not rethrow so that other promises can settle\n\t\t})));\n\n\t\tif (typeof firstError !== 'undefined') {\n\t\t\tthrow firstError;\n\t\t}\n\n\t\treturn result as unknown as T[]; // cast is needed and protected by the `throw` above\n\t}\n\n\t/**\n\t * A helper to create a new `Promise<T>` with a body that is a promise\n\t * itself. By default, an error that raises from the async body will\n\t * end up as a unhandled rejection, so this utility properly awaits the\n\t * body and rejects the promise as a normal promise does without async\n\t * body.\n\t *\n\t * This method should only be used in rare cases where otherwise `async`\n\t * cannot be used (e.g. when callbacks are involved that require this).\n\t */\n\texport function withAsyncBody<T, E = Error>(bodyFn: (resolve: (value: T) => unknown, reject: (error: E) => unknown) => Promise<unknown>): Promise<T> {\n\t\t// eslint-disable-next-line no-async-promise-executor\n\t\treturn new Promise<T>(async (resolve, reject) => {\n\t\t\ttry {\n\t\t\t\tawait bodyFn(resolve, reject);\n\t\t\t} catch (error) {\n\t\t\t\treject(error);\n\t\t\t}\n\t\t});\n\t}\n}\n\n//#endregion\n\n//#region\n\nconst enum AsyncIterableSourceState {\n\tInitial,\n\tDoneOK,\n\tDoneError,\n}\n\n/**\n * An object that allows to emit async values asynchronously or bring the iterable to an error state using `reject()`.\n * This emitter is valid only for the duration of the executor (until the promise returned by the executor settles).\n */\nexport interface AsyncIterableEmitter<T> {\n\t/**\n\t * The value will be appended at the end.\n\t *\n\t * **NOTE** If `reject()` has already been called, this method has no effect.\n\t */\n\temitOne(value: T): void;\n\t/**\n\t * The values will be appended at the end.\n\t *\n\t * **NOTE** If `reject()` has already been called, this method has no effect.\n\t */\n\temitMany(values: T[]): void;\n\t/**\n\t * Writing an error will permanently invalidate this iterable.\n\t * The current users will receive an error thrown, as will all future users.\n\t *\n\t * **NOTE** If `reject()` have already been called, this method has no effect.\n\t */\n\treject(error: Error): void;\n}\n\n/**\n * An executor for the `AsyncIterableObject` that has access to an emitter.\n */\nexport interface AsyncIterableExecutor<T> {\n\t/**\n\t * @param emitter An object that allows to emit async values valid only for the duration of the executor.\n\t */\n\t(emitter: AsyncIterableEmitter<T>): void | Promise<void>;\n}\n\n/**\n * A rich implementation for an `AsyncIterable<T>`.\n */\nexport class AsyncIterableObject<T> implements AsyncIterable<T> {\n\n\tpublic static fromArray<T>(items: T[]): AsyncIterableObject<T> {\n\t\treturn new AsyncIterableObject<T>((writer) => {\n\t\t\twriter.emitMany(items);\n\t\t});\n\t}\n\n\tpublic static fromPromise<T>(promise: Promise<T[]>): AsyncIterableObject<T> {\n\t\treturn new AsyncIterableObject<T>(async (emitter) => {\n\t\t\temitter.emitMany(await promise);\n\t\t});\n\t}\n\n\tpublic static fromPromises<T>(promises: Promise<T>[]): AsyncIterableObject<T> {\n\t\treturn new AsyncIterableObject<T>(async (emitter) => {\n\t\t\tawait Promise.all(promises.map(async (p) => emitter.emitOne(await p)));\n\t\t});\n\t}\n\n\tpublic static merge<T>(iterables: AsyncIterable<T>[]): AsyncIterableObject<T> {\n\t\treturn new AsyncIterableObject(async (emitter) => {\n\t\t\tawait Promise.all(iterables.map(async (iterable) => {\n\t\t\t\tfor await (const item of iterable) {\n\t\t\t\t\temitter.emitOne(item);\n\t\t\t\t}\n\t\t\t}));\n\t\t});\n\t}\n\n\tpublic static EMPTY = AsyncIterableObject.fromArray<any>([]);\n\n\tprivate _state: AsyncIterableSourceState;\n\tprivate _results: T[];\n\tprivate _error: Error | null;\n\tprivate readonly _onStateChanged: Emitter<void>;\n\n\tconstructor(executor: AsyncIterableExecutor<T>) {\n\t\tthis._state = AsyncIterableSourceState.Initial;\n\t\tthis._results = [];\n\t\tthis._error = null;\n\t\tthis._onStateChanged = new Emitter<void>();\n\n\t\tqueueMicrotask(async () => {\n\t\t\tconst writer: AsyncIterableEmitter<T> = {\n\t\t\t\temitOne: (item) => this.emitOne(item),\n\t\t\t\temitMany: (items) => this.emitMany(items),\n\t\t\t\treject: (error) => this.reject(error)\n\t\t\t};\n\t\t\ttry {\n\t\t\t\tawait Promise.resolve(executor(writer));\n\t\t\t\tthis.resolve();\n\t\t\t} catch (err) {\n\t\t\t\tthis.reject(err);\n\t\t\t} finally {\n\t\t\t\twriter.emitOne = undefined!;\n\t\t\t\twriter.emitMany = undefined!;\n\t\t\t\twriter.reject = undefined!;\n\t\t\t}\n\t\t});\n\t}\n\n\t[Symbol.asyncIterator](): AsyncIterator<T, undefined, undefined> {\n\t\tlet i = 0;\n\t\treturn {\n\t\t\tnext: async () => {\n\t\t\t\tdo {\n\t\t\t\t\tif (this._state === AsyncIterableSourceState.DoneError) {\n\t\t\t\t\t\tthrow this._error;\n\t\t\t\t\t}\n\t\t\t\t\tif (i < this._results.length) {\n\t\t\t\t\t\treturn { done: false, value: this._results[i++] };\n\t\t\t\t\t}\n\t\t\t\t\tif (this._state === AsyncIterableSourceState.DoneOK) {\n\t\t\t\t\t\treturn { done: true, value: undefined };\n\t\t\t\t\t}\n\t\t\t\t\tawait Event.toPromise(this._onStateChanged.event);\n\t\t\t\t} while (true);\n\t\t\t}\n\t\t};\n\t}\n\n\tpublic static map<T, R>(iterable: AsyncIterable<T>, mapFn: (item: T) => R): AsyncIterableObject<R> {\n\t\treturn new AsyncIterableObject<R>(async (emitter) => {\n\t\t\tfor await (const item of iterable) {\n\t\t\t\temitter.emitOne(mapFn(item));\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic map<R>(mapFn: (item: T) => R): AsyncIterableObject<R> {\n\t\treturn AsyncIterableObject.map(this, mapFn);\n\t}\n\n\tpublic static filter<T>(iterable: AsyncIterable<T>, filterFn: (item: T) => boolean): AsyncIterableObject<T> {\n\t\treturn new AsyncIterableObject<T>(async (emitter) => {\n\t\t\tfor await (const item of iterable) {\n\t\t\t\tif (filterFn(item)) {\n\t\t\t\t\temitter.emitOne(item);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic filter(filterFn: (item: T) => boolean): AsyncIterableObject<T> {\n\t\treturn AsyncIterableObject.filter(this, filterFn);\n\t}\n\n\tpublic static coalesce<T>(iterable: AsyncIterable<T | undefined | null>): AsyncIterableObject<T> {\n\t\treturn <AsyncIterableObject<T>>AsyncIterableObject.filter(iterable, item => !!item);\n\t}\n\n\tpublic coalesce(): AsyncIterableObject<NonNullable<T>> {\n\t\treturn AsyncIterableObject.coalesce(this) as AsyncIterableObject<NonNullable<T>>;\n\t}\n\n\tpublic static async toPromise<T>(iterable: AsyncIterable<T>): Promise<T[]> {\n\t\tconst result: T[] = [];\n\t\tfor await (const item of iterable) {\n\t\t\tresult.push(item);\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic toPromise(): Promise<T[]> {\n\t\treturn AsyncIterableObject.toPromise(this);\n\t}\n\n\t/**\n\t * The value will be appended at the end.\n\t *\n\t * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.\n\t */\n\tprivate emitOne(value: T): void {\n\t\tif (this._state !== AsyncIterableSourceState.Initial) {\n\t\t\treturn;\n\t\t}\n\t\t// it is important to add new values at the end,\n\t\t// as we may have iterators already running on the array\n\t\tthis._results.push(value);\n\t\tthis._onStateChanged.fire();\n\t}\n\n\t/**\n\t * The values will be appended at the end.\n\t *\n\t * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.\n\t */\n\tprivate emitMany(values: T[]): void {\n\t\tif (this._state !== AsyncIterableSourceState.Initial) {\n\t\t\treturn;\n\t\t}\n\t\t// it is important to add new values at the end,\n\t\t// as we may have iterators already running on the array\n\t\tthis._results = this._results.concat(values);\n\t\tthis._onStateChanged.fire();\n\t}\n\n\t/**\n\t * Calling `resolve()` will mark the result array as complete.\n\t *\n\t * **NOTE** `resolve()` must be called, otherwise all consumers of this iterable will hang indefinitely, similar to a non-resolved promise.\n\t * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.\n\t */\n\tprivate resolve(): void {\n\t\tif (this._state !== AsyncIterableSourceState.Initial) {\n\t\t\treturn;\n\t\t}\n\t\tthis._state = AsyncIterableSourceState.DoneOK;\n\t\tthis._onStateChanged.fire();\n\t}\n\n\t/**\n\t * Writing an error will permanently invalidate this iterable.\n\t * The current users will receive an error thrown, as will all future users.\n\t *\n\t * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.\n\t */\n\tprivate reject(error: Error) {\n\t\tif (this._state !== AsyncIterableSourceState.Initial) {\n\t\t\treturn;\n\t\t}\n\t\tthis._state = AsyncIterableSourceState.DoneError;\n\t\tthis._error = error;\n\t\tthis._onStateChanged.fire();\n\t}\n}\n\nexport class CancelableAsyncIterableObject<T> extends AsyncIterableObject<T> {\n\tconstructor(\n\t\tprivate readonly _source: CancellationTokenSource,\n\t\texecutor: AsyncIterableExecutor<T>\n\t) {\n\t\tsuper(executor);\n\t}\n\n\tcancel(): void {\n\t\tthis._source.cancel();\n\t}\n}\n\nexport function createCancelableAsyncIterable<T>(callback: (token: CancellationToken) => AsyncIterable<T>): CancelableAsyncIterableObject<T> {\n\tconst source = new CancellationTokenSource();\n\tconst innerIterable = callback(source.token);\n\n\treturn new CancelableAsyncIterableObject<T>(source, async (emitter) => {\n\t\tconst subscription = source.token.onCancellationRequested(() => {\n\t\t\tsubscription.dispose();\n\t\t\tsource.dispose();\n\t\t\temitter.reject(new CancellationError());\n\t\t});\n\t\ttry {\n\t\t\tfor await (const item of innerIterable) {\n\t\t\t\tif (source.token.isCancellationRequested) {\n\t\t\t\t\t// canceled in the meantime\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\temitter.emitOne(item);\n\t\t\t}\n\t\t\tsubscription.dispose();\n\t\t\tsource.dispose();\n\t\t} catch (err) {\n\t\t\tsubscription.dispose();\n\t\t\tsource.dispose();\n\t\t\temitter.reject(err);\n\t\t}\n\t});\n}\n\n//#endregion\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from 'vs/base/common/charCode';\n\nexport const enum StringEOL {\n\tUnknown = 0,\n\tInvalid = 3,\n\tLF = 1,\n\tCRLF = 2\n}\n\nexport function countEOL(text: string): [number, number, number, StringEOL] {\n\tlet eolCount = 0;\n\tlet firstLineLength = 0;\n\tlet lastLineStart = 0;\n\tlet eol: StringEOL = StringEOL.Unknown;\n\tfor (let i = 0, len = text.length; i < len; i++) {\n\t\tconst chr = text.charCodeAt(i);\n\n\t\tif (chr === CharCode.CarriageReturn) {\n\t\t\tif (eolCount === 0) {\n\t\t\t\tfirstLineLength = i;\n\t\t\t}\n\t\t\teolCount++;\n\t\t\tif (i + 1 < len && text.charCodeAt(i + 1) === CharCode.LineFeed) {\n\t\t\t\t// \\r\\n... case\n\t\t\t\teol |= StringEOL.CRLF;\n\t\t\t\ti++; // skip \\n\n\t\t\t} else {\n\t\t\t\t// \\r... case\n\t\t\t\teol |= StringEOL.Invalid;\n\t\t\t}\n\t\t\tlastLineStart = i + 1;\n\t\t} else if (chr === CharCode.LineFeed) {\n\t\t\t// \\n... case\n\t\t\teol |= StringEOL.LF;\n\t\t\tif (eolCount === 0) {\n\t\t\t\tfirstLineLength = i;\n\t\t\t}\n\t\t\teolCount++;\n\t\t\tlastLineStart = i + 1;\n\t\t}\n\t}\n\tif (eolCount === 0) {\n\t\tfirstLineLength = text.length;\n\t}\n\treturn [eolCount, firstLineLength, text.length - lastLineStart, eol];\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n/**\n * Open ended enum at runtime\n */\nexport const enum LanguageId {\n\tNull = 0,\n\tPlainText = 1\n}\n\n/**\n * A font style. Values are 2^x such that a bit mask can be used.\n */\nexport const enum FontStyle {\n\tNotSet = -1,\n\tNone = 0,\n\tItalic = 1,\n\tBold = 2,\n\tUnderline = 4,\n\tStrikethrough = 8,\n}\n\n/**\n * Open ended enum at runtime\n */\nexport const enum ColorId {\n\tNone = 0,\n\tDefaultForeground = 1,\n\tDefaultBackground = 2\n}\n\n/**\n * A standard token type.\n */\nexport const enum StandardTokenType {\n\tOther = 0,\n\tComment = 1,\n\tString = 2,\n\tRegEx = 3\n}\n\n/**\n * Helpers to manage the \"collapsed\" metadata of an entire StackElement stack.\n * The following assumptions have been made:\n *  - languageId < 256 => needs 8 bits\n *  - unique color count < 512 => needs 9 bits\n *\n * The binary format is:\n * - -------------------------------------------\n *     3322 2222 2222 1111 1111 1100 0000 0000\n *     1098 7654 3210 9876 5432 1098 7654 3210\n * - -------------------------------------------\n *     xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx\n *     bbbb bbbb ffff ffff fFFF FBTT LLLL LLLL\n * - -------------------------------------------\n *  - L = LanguageId (8 bits)\n *  - T = StandardTokenType (2 bits)\n *  - B = Balanced bracket (1 bit)\n *  - F = FontStyle (4 bits)\n *  - f = foreground color (9 bits)\n *  - b = background color (9 bits)\n *\n */\nexport const enum MetadataConsts {\n\tLANGUAGEID_MASK = 0b00000000000000000000000011111111,\n\tTOKEN_TYPE_MASK = 0b00000000000000000000001100000000,\n\tBALANCED_BRACKETS_MASK = 0b00000000000000000000010000000000,\n\tFONT_STYLE_MASK = 0b00000000000000000111100000000000,\n\tFOREGROUND_MASK = 0b00000000111111111000000000000000,\n\tBACKGROUND_MASK = 0b11111111000000000000000000000000,\n\n\tITALIC_MASK = 0b00000000000000000000100000000000,\n\tBOLD_MASK = 0b00000000000000000001000000000000,\n\tUNDERLINE_MASK = 0b00000000000000000010000000000000,\n\tSTRIKETHROUGH_MASK = 0b00000000000000000100000000000000,\n\n\t// Semantic tokens cannot set the language id, so we can\n\t// use the first 8 bits for control purposes\n\tSEMANTIC_USE_ITALIC = 0b00000000000000000000000000000001,\n\tSEMANTIC_USE_BOLD = 0b00000000000000000000000000000010,\n\tSEMANTIC_USE_UNDERLINE = 0b00000000000000000000000000000100,\n\tSEMANTIC_USE_STRIKETHROUGH = 0b00000000000000000000000000001000,\n\tSEMANTIC_USE_FOREGROUND = 0b00000000000000000000000000010000,\n\tSEMANTIC_USE_BACKGROUND = 0b00000000000000000000000000100000,\n\n\tLANGUAGEID_OFFSET = 0,\n\tTOKEN_TYPE_OFFSET = 8,\n\tBALANCED_BRACKETS_OFFSET = 10,\n\tFONT_STYLE_OFFSET = 11,\n\tFOREGROUND_OFFSET = 15,\n\tBACKGROUND_OFFSET = 24\n}\n\n/**\n */\nexport class TokenMetadata {\n\n\tpublic static getLanguageId(metadata: number): LanguageId {\n\t\treturn (metadata & MetadataConsts.LANGUAGEID_MASK) >>> MetadataConsts.LANGUAGEID_OFFSET;\n\t}\n\n\tpublic static getTokenType(metadata: number): StandardTokenType {\n\t\treturn (metadata & MetadataConsts.TOKEN_TYPE_MASK) >>> MetadataConsts.TOKEN_TYPE_OFFSET;\n\t}\n\n\tpublic static containsBalancedBrackets(metadata: number): boolean {\n\t\treturn (metadata & MetadataConsts.BALANCED_BRACKETS_MASK) !== 0;\n\t}\n\n\tpublic static getFontStyle(metadata: number): FontStyle {\n\t\treturn (metadata & MetadataConsts.FONT_STYLE_MASK) >>> MetadataConsts.FONT_STYLE_OFFSET;\n\t}\n\n\tpublic static getForeground(metadata: number): ColorId {\n\t\treturn (metadata & MetadataConsts.FOREGROUND_MASK) >>> MetadataConsts.FOREGROUND_OFFSET;\n\t}\n\n\tpublic static getBackground(metadata: number): ColorId {\n\t\treturn (metadata & MetadataConsts.BACKGROUND_MASK) >>> MetadataConsts.BACKGROUND_OFFSET;\n\t}\n\n\tpublic static getClassNameFromMetadata(metadata: number): string {\n\t\tconst foreground = this.getForeground(metadata);\n\t\tlet className = 'mtk' + foreground;\n\n\t\tconst fontStyle = this.getFontStyle(metadata);\n\t\tif (fontStyle & FontStyle.Italic) {\n\t\t\tclassName += ' mtki';\n\t\t}\n\t\tif (fontStyle & FontStyle.Bold) {\n\t\t\tclassName += ' mtkb';\n\t\t}\n\t\tif (fontStyle & FontStyle.Underline) {\n\t\t\tclassName += ' mtku';\n\t\t}\n\t\tif (fontStyle & FontStyle.Strikethrough) {\n\t\t\tclassName += ' mtks';\n\t\t}\n\n\t\treturn className;\n\t}\n\n\tpublic static getInlineStyleFromMetadata(metadata: number, colorMap: string[]): string {\n\t\tconst foreground = this.getForeground(metadata);\n\t\tconst fontStyle = this.getFontStyle(metadata);\n\n\t\tlet result = `color: ${colorMap[foreground]};`;\n\t\tif (fontStyle & FontStyle.Italic) {\n\t\t\tresult += 'font-style: italic;';\n\t\t}\n\t\tif (fontStyle & FontStyle.Bold) {\n\t\t\tresult += 'font-weight: bold;';\n\t\t}\n\t\tlet textDecoration = '';\n\t\tif (fontStyle & FontStyle.Underline) {\n\t\t\ttextDecoration += ' underline';\n\t\t}\n\t\tif (fontStyle & FontStyle.Strikethrough) {\n\t\t\ttextDecoration += ' line-through';\n\t\t}\n\t\tif (textDecoration) {\n\t\t\tresult += `text-decoration:${textDecoration};`;\n\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic static getPresentationFromMetadata(metadata: number): ITokenPresentation {\n\t\tconst foreground = this.getForeground(metadata);\n\t\tconst fontStyle = this.getFontStyle(metadata);\n\n\t\treturn {\n\t\t\tforeground: foreground,\n\t\t\titalic: Boolean(fontStyle & FontStyle.Italic),\n\t\t\tbold: Boolean(fontStyle & FontStyle.Bold),\n\t\t\tunderline: Boolean(fontStyle & FontStyle.Underline),\n\t\t\tstrikethrough: Boolean(fontStyle & FontStyle.Strikethrough),\n\t\t};\n\t}\n}\n\n/**\n */\nexport interface ITokenPresentation {\n\tforeground: ColorId;\n\titalic: boolean;\n\tbold: boolean;\n\tunderline: boolean;\n\tstrikethrough: boolean;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Token, TokenizationResult, EncodedTokenizationResult, IState } from 'vs/editor/common/languages';\nimport { LanguageId, FontStyle, ColorId, StandardTokenType, MetadataConsts } from 'vs/editor/common/encodedTokenAttributes';\n\nexport const NullState: IState = new class implements IState {\n\tpublic clone(): IState {\n\t\treturn this;\n\t}\n\tpublic equals(other: IState): boolean {\n\t\treturn (this === other);\n\t}\n};\n\nexport function nullTokenize(languageId: string, state: IState): TokenizationResult {\n\treturn new TokenizationResult([new Token(0, '', languageId)], state);\n}\n\nexport function nullTokenizeEncoded(languageId: LanguageId, state: IState | null): EncodedTokenizationResult {\n\tconst tokens = new Uint32Array(2);\n\ttokens[0] = 0;\n\ttokens[1] = (\n\t\t(languageId << MetadataConsts.LANGUAGEID_OFFSET)\n\t\t| (StandardTokenType.Other << MetadataConsts.TOKEN_TYPE_OFFSET)\n\t\t| (FontStyle.None << MetadataConsts.FONT_STYLE_OFFSET)\n\t\t| (ColorId.DefaultForeground << MetadataConsts.FOREGROUND_OFFSET)\n\t\t| (ColorId.DefaultBackground << MetadataConsts.BACKGROUND_OFFSET)\n\t) >>> 0;\n\n\treturn new EncodedTokenizationResult(tokens, state === null ? NullState : state);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { ILanguageIdCodec } from 'vs/editor/common/languages';\nimport { FontStyle, ColorId, StandardTokenType, MetadataConsts, TokenMetadata, ITokenPresentation } from 'vs/editor/common/encodedTokenAttributes';\n\nexport interface IViewLineTokens {\n\tequals(other: IViewLineTokens): boolean;\n\tgetCount(): number;\n\tgetForeground(tokenIndex: number): ColorId;\n\tgetEndOffset(tokenIndex: number): number;\n\tgetClassName(tokenIndex: number): string;\n\tgetInlineStyle(tokenIndex: number, colorMap: string[]): string;\n\tgetPresentation(tokenIndex: number): ITokenPresentation;\n\tfindTokenIndexAtOffset(offset: number): number;\n\tgetLineContent(): string;\n\tgetMetadata(tokenIndex: number): number;\n\tgetLanguageId(tokenIndex: number): string;\n}\n\nexport class LineTokens implements IViewLineTokens {\n\t_lineTokensBrand: void = undefined;\n\n\tprivate readonly _tokens: Uint32Array;\n\tprivate readonly _tokensCount: number;\n\tprivate readonly _text: string;\n\tprivate readonly _languageIdCodec: ILanguageIdCodec;\n\n\tpublic static defaultTokenMetadata = (\n\t\t(FontStyle.None << MetadataConsts.FONT_STYLE_OFFSET)\n\t\t| (ColorId.DefaultForeground << MetadataConsts.FOREGROUND_OFFSET)\n\t\t| (ColorId.DefaultBackground << MetadataConsts.BACKGROUND_OFFSET)\n\t) >>> 0;\n\n\tpublic static createEmpty(lineContent: string, decoder: ILanguageIdCodec): LineTokens {\n\t\tconst defaultMetadata = LineTokens.defaultTokenMetadata;\n\n\t\tconst tokens = new Uint32Array(2);\n\t\ttokens[0] = lineContent.length;\n\t\ttokens[1] = defaultMetadata;\n\n\t\treturn new LineTokens(tokens, lineContent, decoder);\n\t}\n\n\tconstructor(tokens: Uint32Array, text: string, decoder: ILanguageIdCodec) {\n\t\tthis._tokens = tokens;\n\t\tthis._tokensCount = (this._tokens.length >>> 1);\n\t\tthis._text = text;\n\t\tthis._languageIdCodec = decoder;\n\t}\n\n\tpublic equals(other: IViewLineTokens): boolean {\n\t\tif (other instanceof LineTokens) {\n\t\t\treturn this.slicedEquals(other, 0, this._tokensCount);\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic slicedEquals(other: LineTokens, sliceFromTokenIndex: number, sliceTokenCount: number): boolean {\n\t\tif (this._text !== other._text) {\n\t\t\treturn false;\n\t\t}\n\t\tif (this._tokensCount !== other._tokensCount) {\n\t\t\treturn false;\n\t\t}\n\t\tconst from = (sliceFromTokenIndex << 1);\n\t\tconst to = from + (sliceTokenCount << 1);\n\t\tfor (let i = from; i < to; i++) {\n\t\t\tif (this._tokens[i] !== other._tokens[i]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tpublic getLineContent(): string {\n\t\treturn this._text;\n\t}\n\n\tpublic getCount(): number {\n\t\treturn this._tokensCount;\n\t}\n\n\tpublic getStartOffset(tokenIndex: number): number {\n\t\tif (tokenIndex > 0) {\n\t\t\treturn this._tokens[(tokenIndex - 1) << 1];\n\t\t}\n\t\treturn 0;\n\t}\n\n\tpublic getMetadata(tokenIndex: number): number {\n\t\tconst metadata = this._tokens[(tokenIndex << 1) + 1];\n\t\treturn metadata;\n\t}\n\n\tpublic getLanguageId(tokenIndex: number): string {\n\t\tconst metadata = this._tokens[(tokenIndex << 1) + 1];\n\t\tconst languageId = TokenMetadata.getLanguageId(metadata);\n\t\treturn this._languageIdCodec.decodeLanguageId(languageId);\n\t}\n\n\tpublic getStandardTokenType(tokenIndex: number): StandardTokenType {\n\t\tconst metadata = this._tokens[(tokenIndex << 1) + 1];\n\t\treturn TokenMetadata.getTokenType(metadata);\n\t}\n\n\tpublic getForeground(tokenIndex: number): ColorId {\n\t\tconst metadata = this._tokens[(tokenIndex << 1) + 1];\n\t\treturn TokenMetadata.getForeground(metadata);\n\t}\n\n\tpublic getClassName(tokenIndex: number): string {\n\t\tconst metadata = this._tokens[(tokenIndex << 1) + 1];\n\t\treturn TokenMetadata.getClassNameFromMetadata(metadata);\n\t}\n\n\tpublic getInlineStyle(tokenIndex: number, colorMap: string[]): string {\n\t\tconst metadata = this._tokens[(tokenIndex << 1) + 1];\n\t\treturn TokenMetadata.getInlineStyleFromMetadata(metadata, colorMap);\n\t}\n\n\tpublic getPresentation(tokenIndex: number): ITokenPresentation {\n\t\tconst metadata = this._tokens[(tokenIndex << 1) + 1];\n\t\treturn TokenMetadata.getPresentationFromMetadata(metadata);\n\t}\n\n\tpublic getEndOffset(tokenIndex: number): number {\n\t\treturn this._tokens[tokenIndex << 1];\n\t}\n\n\t/**\n\t * Find the token containing offset `offset`.\n\t * @param offset The search offset\n\t * @return The index of the token containing the offset.\n\t */\n\tpublic findTokenIndexAtOffset(offset: number): number {\n\t\treturn LineTokens.findIndexInTokensArray(this._tokens, offset);\n\t}\n\n\tpublic inflate(): IViewLineTokens {\n\t\treturn this;\n\t}\n\n\tpublic sliceAndInflate(startOffset: number, endOffset: number, deltaOffset: number): IViewLineTokens {\n\t\treturn new SliceLineTokens(this, startOffset, endOffset, deltaOffset);\n\t}\n\n\tpublic static convertToEndOffset(tokens: Uint32Array, lineTextLength: number): void {\n\t\tconst tokenCount = (tokens.length >>> 1);\n\t\tconst lastTokenIndex = tokenCount - 1;\n\t\tfor (let tokenIndex = 0; tokenIndex < lastTokenIndex; tokenIndex++) {\n\t\t\ttokens[tokenIndex << 1] = tokens[(tokenIndex + 1) << 1];\n\t\t}\n\t\ttokens[lastTokenIndex << 1] = lineTextLength;\n\t}\n\n\tpublic static findIndexInTokensArray(tokens: Uint32Array, desiredIndex: number): number {\n\t\tif (tokens.length <= 2) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tlet low = 0;\n\t\tlet high = (tokens.length >>> 1) - 1;\n\n\t\twhile (low < high) {\n\n\t\t\tconst mid = low + Math.floor((high - low) / 2);\n\t\t\tconst endOffset = tokens[(mid << 1)];\n\n\t\t\tif (endOffset === desiredIndex) {\n\t\t\t\treturn mid + 1;\n\t\t\t} else if (endOffset < desiredIndex) {\n\t\t\t\tlow = mid + 1;\n\t\t\t} else if (endOffset > desiredIndex) {\n\t\t\t\thigh = mid;\n\t\t\t}\n\t\t}\n\n\t\treturn low;\n\t}\n\n\t/**\n\t * @pure\n\t * @param insertTokens Must be sorted by offset.\n\t*/\n\tpublic withInserted(insertTokens: { offset: number; text: string; tokenMetadata: number }[]): LineTokens {\n\t\tif (insertTokens.length === 0) {\n\t\t\treturn this;\n\t\t}\n\n\t\tlet nextOriginalTokenIdx = 0;\n\t\tlet nextInsertTokenIdx = 0;\n\t\tlet text = '';\n\t\tconst newTokens = new Array<number>();\n\n\t\tlet originalEndOffset = 0;\n\t\twhile (true) {\n\t\t\tconst nextOriginalTokenEndOffset = nextOriginalTokenIdx < this._tokensCount ? this._tokens[nextOriginalTokenIdx << 1] : -1;\n\t\t\tconst nextInsertToken = nextInsertTokenIdx < insertTokens.length ? insertTokens[nextInsertTokenIdx] : null;\n\n\t\t\tif (nextOriginalTokenEndOffset !== -1 && (nextInsertToken === null || nextOriginalTokenEndOffset <= nextInsertToken.offset)) {\n\t\t\t\t// original token ends before next insert token\n\t\t\t\ttext += this._text.substring(originalEndOffset, nextOriginalTokenEndOffset);\n\t\t\t\tconst metadata = this._tokens[(nextOriginalTokenIdx << 1) + 1];\n\t\t\t\tnewTokens.push(text.length, metadata);\n\t\t\t\tnextOriginalTokenIdx++;\n\t\t\t\toriginalEndOffset = nextOriginalTokenEndOffset;\n\n\t\t\t} else if (nextInsertToken) {\n\t\t\t\tif (nextInsertToken.offset > originalEndOffset) {\n\t\t\t\t\t// insert token is in the middle of the next token.\n\t\t\t\t\ttext += this._text.substring(originalEndOffset, nextInsertToken.offset);\n\t\t\t\t\tconst metadata = this._tokens[(nextOriginalTokenIdx << 1) + 1];\n\t\t\t\t\tnewTokens.push(text.length, metadata);\n\t\t\t\t\toriginalEndOffset = nextInsertToken.offset;\n\t\t\t\t}\n\n\t\t\t\ttext += nextInsertToken.text;\n\t\t\t\tnewTokens.push(text.length, nextInsertToken.tokenMetadata);\n\t\t\t\tnextInsertTokenIdx++;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn new LineTokens(new Uint32Array(newTokens), text, this._languageIdCodec);\n\t}\n}\n\nclass SliceLineTokens implements IViewLineTokens {\n\n\tprivate readonly _source: LineTokens;\n\tprivate readonly _startOffset: number;\n\tprivate readonly _endOffset: number;\n\tprivate readonly _deltaOffset: number;\n\n\tprivate readonly _firstTokenIndex: number;\n\tprivate readonly _tokensCount: number;\n\n\tconstructor(source: LineTokens, startOffset: number, endOffset: number, deltaOffset: number) {\n\t\tthis._source = source;\n\t\tthis._startOffset = startOffset;\n\t\tthis._endOffset = endOffset;\n\t\tthis._deltaOffset = deltaOffset;\n\t\tthis._firstTokenIndex = source.findTokenIndexAtOffset(startOffset);\n\n\t\tthis._tokensCount = 0;\n\t\tfor (let i = this._firstTokenIndex, len = source.getCount(); i < len; i++) {\n\t\t\tconst tokenStartOffset = source.getStartOffset(i);\n\t\t\tif (tokenStartOffset >= endOffset) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tthis._tokensCount++;\n\t\t}\n\t}\n\n\tpublic getMetadata(tokenIndex: number): number {\n\t\treturn this._source.getMetadata(this._firstTokenIndex + tokenIndex);\n\t}\n\n\tpublic getLanguageId(tokenIndex: number): string {\n\t\treturn this._source.getLanguageId(this._firstTokenIndex + tokenIndex);\n\t}\n\n\tpublic getLineContent(): string {\n\t\treturn this._source.getLineContent().substring(this._startOffset, this._endOffset);\n\t}\n\n\tpublic equals(other: IViewLineTokens): boolean {\n\t\tif (other instanceof SliceLineTokens) {\n\t\t\treturn (\n\t\t\t\tthis._startOffset === other._startOffset\n\t\t\t\t&& this._endOffset === other._endOffset\n\t\t\t\t&& this._deltaOffset === other._deltaOffset\n\t\t\t\t&& this._source.slicedEquals(other._source, this._firstTokenIndex, this._tokensCount)\n\t\t\t);\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic getCount(): number {\n\t\treturn this._tokensCount;\n\t}\n\n\tpublic getForeground(tokenIndex: number): ColorId {\n\t\treturn this._source.getForeground(this._firstTokenIndex + tokenIndex);\n\t}\n\n\tpublic getEndOffset(tokenIndex: number): number {\n\t\tconst tokenEndOffset = this._source.getEndOffset(this._firstTokenIndex + tokenIndex);\n\t\treturn Math.min(this._endOffset, tokenEndOffset) - this._startOffset + this._deltaOffset;\n\t}\n\n\tpublic getClassName(tokenIndex: number): string {\n\t\treturn this._source.getClassName(this._firstTokenIndex + tokenIndex);\n\t}\n\n\tpublic getInlineStyle(tokenIndex: number, colorMap: string[]): string {\n\t\treturn this._source.getInlineStyle(this._firstTokenIndex + tokenIndex, colorMap);\n\t}\n\n\tpublic getPresentation(tokenIndex: number): ITokenPresentation {\n\t\treturn this._source.getPresentation(this._firstTokenIndex + tokenIndex);\n\t}\n\n\tpublic findTokenIndexAtOffset(offset: number): number {\n\t\treturn this._source.findTokenIndexAtOffset(offset + this._startOffset - this._deltaOffset) - this._firstTokenIndex;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { LineTokens } from 'vs/editor/common/tokens/lineTokens';\n\nexport const EMPTY_LINE_TOKENS = (new Uint32Array(0)).buffer;\n\nexport class ContiguousTokensEditing {\n\n\tpublic static deleteBeginning(lineTokens: Uint32Array | ArrayBuffer | null, toChIndex: number): Uint32Array | ArrayBuffer | null {\n\t\tif (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS) {\n\t\t\treturn lineTokens;\n\t\t}\n\t\treturn ContiguousTokensEditing.delete(lineTokens, 0, toChIndex);\n\t}\n\n\tpublic static deleteEnding(lineTokens: Uint32Array | ArrayBuffer | null, fromChIndex: number): Uint32Array | ArrayBuffer | null {\n\t\tif (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS) {\n\t\t\treturn lineTokens;\n\t\t}\n\n\t\tconst tokens = toUint32Array(lineTokens);\n\t\tconst lineTextLength = tokens[tokens.length - 2];\n\t\treturn ContiguousTokensEditing.delete(lineTokens, fromChIndex, lineTextLength);\n\t}\n\n\tpublic static delete(lineTokens: Uint32Array | ArrayBuffer | null, fromChIndex: number, toChIndex: number): Uint32Array | ArrayBuffer | null {\n\t\tif (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS || fromChIndex === toChIndex) {\n\t\t\treturn lineTokens;\n\t\t}\n\n\t\tconst tokens = toUint32Array(lineTokens);\n\t\tconst tokensCount = (tokens.length >>> 1);\n\n\t\t// special case: deleting everything\n\t\tif (fromChIndex === 0 && tokens[tokens.length - 2] === toChIndex) {\n\t\t\treturn EMPTY_LINE_TOKENS;\n\t\t}\n\n\t\tconst fromTokenIndex = LineTokens.findIndexInTokensArray(tokens, fromChIndex);\n\t\tconst fromTokenStartOffset = (fromTokenIndex > 0 ? tokens[(fromTokenIndex - 1) << 1] : 0);\n\t\tconst fromTokenEndOffset = tokens[fromTokenIndex << 1];\n\n\t\tif (toChIndex < fromTokenEndOffset) {\n\t\t\t// the delete range is inside a single token\n\t\t\tconst delta = (toChIndex - fromChIndex);\n\t\t\tfor (let i = fromTokenIndex; i < tokensCount; i++) {\n\t\t\t\ttokens[i << 1] -= delta;\n\t\t\t}\n\t\t\treturn lineTokens;\n\t\t}\n\n\t\tlet dest: number;\n\t\tlet lastEnd: number;\n\t\tif (fromTokenStartOffset !== fromChIndex) {\n\t\t\ttokens[fromTokenIndex << 1] = fromChIndex;\n\t\t\tdest = ((fromTokenIndex + 1) << 1);\n\t\t\tlastEnd = fromChIndex;\n\t\t} else {\n\t\t\tdest = (fromTokenIndex << 1);\n\t\t\tlastEnd = fromTokenStartOffset;\n\t\t}\n\n\t\tconst delta = (toChIndex - fromChIndex);\n\t\tfor (let tokenIndex = fromTokenIndex + 1; tokenIndex < tokensCount; tokenIndex++) {\n\t\t\tconst tokenEndOffset = tokens[tokenIndex << 1] - delta;\n\t\t\tif (tokenEndOffset > lastEnd) {\n\t\t\t\ttokens[dest++] = tokenEndOffset;\n\t\t\t\ttokens[dest++] = tokens[(tokenIndex << 1) + 1];\n\t\t\t\tlastEnd = tokenEndOffset;\n\t\t\t}\n\t\t}\n\n\t\tif (dest === tokens.length) {\n\t\t\t// nothing to trim\n\t\t\treturn lineTokens;\n\t\t}\n\n\t\tconst tmp = new Uint32Array(dest);\n\t\ttmp.set(tokens.subarray(0, dest), 0);\n\t\treturn tmp.buffer;\n\t}\n\n\tpublic static append(lineTokens: Uint32Array | ArrayBuffer | null, _otherTokens: Uint32Array | ArrayBuffer | null): Uint32Array | ArrayBuffer | null {\n\t\tif (_otherTokens === EMPTY_LINE_TOKENS) {\n\t\t\treturn lineTokens;\n\t\t}\n\t\tif (lineTokens === EMPTY_LINE_TOKENS) {\n\t\t\treturn _otherTokens;\n\t\t}\n\t\tif (lineTokens === null) {\n\t\t\treturn lineTokens;\n\t\t}\n\t\tif (_otherTokens === null) {\n\t\t\t// cannot determine combined line length...\n\t\t\treturn null;\n\t\t}\n\t\tconst myTokens = toUint32Array(lineTokens);\n\t\tconst otherTokens = toUint32Array(_otherTokens);\n\t\tconst otherTokensCount = (otherTokens.length >>> 1);\n\n\t\tconst result = new Uint32Array(myTokens.length + otherTokens.length);\n\t\tresult.set(myTokens, 0);\n\t\tlet dest = myTokens.length;\n\t\tconst delta = myTokens[myTokens.length - 2];\n\t\tfor (let i = 0; i < otherTokensCount; i++) {\n\t\t\tresult[dest++] = otherTokens[(i << 1)] + delta;\n\t\t\tresult[dest++] = otherTokens[(i << 1) + 1];\n\t\t}\n\t\treturn result.buffer;\n\t}\n\n\tpublic static insert(lineTokens: Uint32Array | ArrayBuffer | null, chIndex: number, textLength: number): Uint32Array | ArrayBuffer | null {\n\t\tif (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS) {\n\t\t\t// nothing to do\n\t\t\treturn lineTokens;\n\t\t}\n\n\t\tconst tokens = toUint32Array(lineTokens);\n\t\tconst tokensCount = (tokens.length >>> 1);\n\n\t\tlet fromTokenIndex = LineTokens.findIndexInTokensArray(tokens, chIndex);\n\t\tif (fromTokenIndex > 0) {\n\t\t\tconst fromTokenStartOffset = tokens[(fromTokenIndex - 1) << 1];\n\t\t\tif (fromTokenStartOffset === chIndex) {\n\t\t\t\tfromTokenIndex--;\n\t\t\t}\n\t\t}\n\t\tfor (let tokenIndex = fromTokenIndex; tokenIndex < tokensCount; tokenIndex++) {\n\t\t\ttokens[tokenIndex << 1] += textLength;\n\t\t}\n\t\treturn lineTokens;\n\t}\n}\n\nexport function toUint32Array(arr: Uint32Array | ArrayBuffer): Uint32Array {\n\tif (arr instanceof Uint32Array) {\n\t\treturn arr;\n\t} else {\n\t\treturn new Uint32Array(arr);\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as arrays from 'vs/base/common/arrays';\nimport { readUInt32BE, writeUInt32BE } from 'vs/base/common/buffer';\nimport { Position } from 'vs/editor/common/core/position';\nimport { IRange } from 'vs/editor/common/core/range';\nimport { countEOL } from 'vs/editor/common/core/eolCounter';\nimport { ContiguousTokensEditing } from 'vs/editor/common/tokens/contiguousTokensEditing';\n\n/**\n * Represents contiguous tokens over a contiguous range of lines.\n */\nexport class ContiguousMultilineTokens {\n\n\tpublic static deserialize(buff: Uint8Array, offset: number, result: ContiguousMultilineTokens[]): number {\n\t\tconst view32 = new Uint32Array(buff.buffer);\n\t\tconst startLineNumber = readUInt32BE(buff, offset); offset += 4;\n\t\tconst count = readUInt32BE(buff, offset); offset += 4;\n\t\tconst tokens: Uint32Array[] = [];\n\t\tfor (let i = 0; i < count; i++) {\n\t\t\tconst byteCount = readUInt32BE(buff, offset); offset += 4;\n\t\t\ttokens.push(view32.subarray(offset / 4, offset / 4 + byteCount / 4));\n\t\t\toffset += byteCount;\n\t\t}\n\t\tresult.push(new ContiguousMultilineTokens(startLineNumber, tokens));\n\t\treturn offset;\n\t}\n\n\t/**\n\t * The start line number for this block of tokens.\n\t */\n\tprivate _startLineNumber: number;\n\n\t/**\n\t * The tokens are stored in a binary format. There is an element for each line,\n\t * so `tokens[index]` contains all tokens on line `startLineNumber + index`.\n\t *\n\t * On a specific line, each token occupies two array indices. For token i:\n\t *  - at offset 2*i => endOffset\n\t *  - at offset 2*i + 1 => metadata\n\t *\n\t */\n\tprivate _tokens: (Uint32Array | ArrayBuffer | null)[];\n\n\t/**\n\t * (Inclusive) start line number for these tokens.\n\t */\n\tpublic get startLineNumber(): number {\n\t\treturn this._startLineNumber;\n\t}\n\n\t/**\n\t * (Inclusive) end line number for these tokens.\n\t */\n\tpublic get endLineNumber(): number {\n\t\treturn this._startLineNumber + this._tokens.length - 1;\n\t}\n\n\tconstructor(startLineNumber: number, tokens: Uint32Array[]) {\n\t\tthis._startLineNumber = startLineNumber;\n\t\tthis._tokens = tokens;\n\t}\n\n\t/**\n\t * @see {@link _tokens}\n\t */\n\tpublic getLineTokens(lineNumber: number): Uint32Array | ArrayBuffer | null {\n\t\treturn this._tokens[lineNumber - this._startLineNumber];\n\t}\n\n\tpublic appendLineTokens(lineTokens: Uint32Array): void {\n\t\tthis._tokens.push(lineTokens);\n\t}\n\n\tpublic serializeSize(): number {\n\t\tlet result = 0;\n\t\tresult += 4; // 4 bytes for the start line number\n\t\tresult += 4; // 4 bytes for the line count\n\t\tfor (let i = 0; i < this._tokens.length; i++) {\n\t\t\tconst lineTokens = this._tokens[i];\n\t\t\tif (!(lineTokens instanceof Uint32Array)) {\n\t\t\t\tthrow new Error(`Not supported!`);\n\t\t\t}\n\t\t\tresult += 4; // 4 bytes for the byte count\n\t\t\tresult += lineTokens.byteLength;\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic serialize(destination: Uint8Array, offset: number): number {\n\t\twriteUInt32BE(destination, this._startLineNumber, offset); offset += 4;\n\t\twriteUInt32BE(destination, this._tokens.length, offset); offset += 4;\n\t\tfor (let i = 0; i < this._tokens.length; i++) {\n\t\t\tconst lineTokens = this._tokens[i];\n\t\t\tif (!(lineTokens instanceof Uint32Array)) {\n\t\t\t\tthrow new Error(`Not supported!`);\n\t\t\t}\n\t\t\twriteUInt32BE(destination, lineTokens.byteLength, offset); offset += 4;\n\t\t\tdestination.set(new Uint8Array(lineTokens.buffer), offset); offset += lineTokens.byteLength;\n\t\t}\n\t\treturn offset;\n\t}\n\n\tpublic applyEdit(range: IRange, text: string): void {\n\t\tconst [eolCount, firstLineLength] = countEOL(text);\n\t\tthis._acceptDeleteRange(range);\n\t\tthis._acceptInsertText(new Position(range.startLineNumber, range.startColumn), eolCount, firstLineLength);\n\t}\n\n\tprivate _acceptDeleteRange(range: IRange): void {\n\t\tif (range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn) {\n\t\t\t// Nothing to delete\n\t\t\treturn;\n\t\t}\n\n\t\tconst firstLineIndex = range.startLineNumber - this._startLineNumber;\n\t\tconst lastLineIndex = range.endLineNumber - this._startLineNumber;\n\n\t\tif (lastLineIndex < 0) {\n\t\t\t// this deletion occurs entirely before this block, so we only need to adjust line numbers\n\t\t\tconst deletedLinesCount = lastLineIndex - firstLineIndex;\n\t\t\tthis._startLineNumber -= deletedLinesCount;\n\t\t\treturn;\n\t\t}\n\n\t\tif (firstLineIndex >= this._tokens.length) {\n\t\t\t// this deletion occurs entirely after this block, so there is nothing to do\n\t\t\treturn;\n\t\t}\n\n\t\tif (firstLineIndex < 0 && lastLineIndex >= this._tokens.length) {\n\t\t\t// this deletion completely encompasses this block\n\t\t\tthis._startLineNumber = 0;\n\t\t\tthis._tokens = [];\n\t\t\treturn;\n\t\t}\n\n\t\tif (firstLineIndex === lastLineIndex) {\n\t\t\t// a delete on a single line\n\t\t\tthis._tokens[firstLineIndex] = ContiguousTokensEditing.delete(this._tokens[firstLineIndex], range.startColumn - 1, range.endColumn - 1);\n\t\t\treturn;\n\t\t}\n\n\t\tif (firstLineIndex >= 0) {\n\t\t\t// The first line survives\n\t\t\tthis._tokens[firstLineIndex] = ContiguousTokensEditing.deleteEnding(this._tokens[firstLineIndex], range.startColumn - 1);\n\n\t\t\tif (lastLineIndex < this._tokens.length) {\n\t\t\t\t// The last line survives\n\t\t\t\tconst lastLineTokens = ContiguousTokensEditing.deleteBeginning(this._tokens[lastLineIndex], range.endColumn - 1);\n\n\t\t\t\t// Take remaining text on last line and append it to remaining text on first line\n\t\t\t\tthis._tokens[firstLineIndex] = ContiguousTokensEditing.append(this._tokens[firstLineIndex], lastLineTokens);\n\n\t\t\t\t// Delete middle lines\n\t\t\t\tthis._tokens.splice(firstLineIndex + 1, lastLineIndex - firstLineIndex);\n\t\t\t} else {\n\t\t\t\t// The last line does not survive\n\n\t\t\t\t// Take remaining text on last line and append it to remaining text on first line\n\t\t\t\tthis._tokens[firstLineIndex] = ContiguousTokensEditing.append(this._tokens[firstLineIndex], null);\n\n\t\t\t\t// Delete lines\n\t\t\t\tthis._tokens = this._tokens.slice(0, firstLineIndex + 1);\n\t\t\t}\n\t\t} else {\n\t\t\t// The first line does not survive\n\n\t\t\tconst deletedBefore = -firstLineIndex;\n\t\t\tthis._startLineNumber -= deletedBefore;\n\n\t\t\t// Remove beginning from last line\n\t\t\tthis._tokens[lastLineIndex] = ContiguousTokensEditing.deleteBeginning(this._tokens[lastLineIndex], range.endColumn - 1);\n\n\t\t\t// Delete lines\n\t\t\tthis._tokens = this._tokens.slice(lastLineIndex);\n\t\t}\n\t}\n\n\tprivate _acceptInsertText(position: Position, eolCount: number, firstLineLength: number): void {\n\n\t\tif (eolCount === 0 && firstLineLength === 0) {\n\t\t\t// Nothing to insert\n\t\t\treturn;\n\t\t}\n\n\t\tconst lineIndex = position.lineNumber - this._startLineNumber;\n\n\t\tif (lineIndex < 0) {\n\t\t\t// this insertion occurs before this block, so we only need to adjust line numbers\n\t\t\tthis._startLineNumber += eolCount;\n\t\t\treturn;\n\t\t}\n\n\t\tif (lineIndex >= this._tokens.length) {\n\t\t\t// this insertion occurs after this block, so there is nothing to do\n\t\t\treturn;\n\t\t}\n\n\t\tif (eolCount === 0) {\n\t\t\t// Inserting text on one line\n\t\t\tthis._tokens[lineIndex] = ContiguousTokensEditing.insert(this._tokens[lineIndex], position.column - 1, firstLineLength);\n\t\t\treturn;\n\t\t}\n\n\t\tthis._tokens[lineIndex] = ContiguousTokensEditing.deleteEnding(this._tokens[lineIndex], position.column - 1);\n\t\tthis._tokens[lineIndex] = ContiguousTokensEditing.insert(this._tokens[lineIndex], position.column - 1, firstLineLength);\n\n\t\tthis._insertLines(position.lineNumber, eolCount);\n\t}\n\n\tprivate _insertLines(insertIndex: number, insertCount: number): void {\n\t\tif (insertCount === 0) {\n\t\t\treturn;\n\t\t}\n\t\tconst lineTokens: (Uint32Array | ArrayBuffer | null)[] = [];\n\t\tfor (let i = 0; i < insertCount; i++) {\n\t\t\tlineTokens[i] = null;\n\t\t}\n\t\tthis._tokens = arrays.arrayInsert(this._tokens, insertIndex, lineTokens);\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { readUInt32BE, writeUInt32BE } from 'vs/base/common/buffer';\nimport { ContiguousMultilineTokens } from 'vs/editor/common/tokens/contiguousMultilineTokens';\n\nexport class ContiguousMultilineTokensBuilder {\n\n\tpublic static deserialize(buff: Uint8Array): ContiguousMultilineTokens[] {\n\t\tlet offset = 0;\n\t\tconst count = readUInt32BE(buff, offset); offset += 4;\n\t\tconst result: ContiguousMultilineTokens[] = [];\n\t\tfor (let i = 0; i < count; i++) {\n\t\t\toffset = ContiguousMultilineTokens.deserialize(buff, offset, result);\n\t\t}\n\t\treturn result;\n\t}\n\n\tprivate readonly _tokens: ContiguousMultilineTokens[];\n\n\tconstructor() {\n\t\tthis._tokens = [];\n\t}\n\n\tpublic add(lineNumber: number, lineTokens: Uint32Array): void {\n\t\tif (this._tokens.length > 0) {\n\t\t\tconst last = this._tokens[this._tokens.length - 1];\n\t\t\tif (last.endLineNumber + 1 === lineNumber) {\n\t\t\t\t// append\n\t\t\t\tlast.appendLineTokens(lineTokens);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tthis._tokens.push(new ContiguousMultilineTokens(lineNumber, [lineTokens]));\n\t}\n\n\tpublic finalize(): ContiguousMultilineTokens[] {\n\t\treturn this._tokens;\n\t}\n\n\tpublic serialize(): Uint8Array {\n\t\tconst size = this._serializeSize();\n\t\tconst result = new Uint8Array(size);\n\t\tthis._serialize(result);\n\t\treturn result;\n\t}\n\n\tprivate _serializeSize(): number {\n\t\tlet result = 0;\n\t\tresult += 4; // 4 bytes for the count\n\t\tfor (let i = 0; i < this._tokens.length; i++) {\n\t\t\tresult += this._tokens[i].serializeSize();\n\t\t}\n\t\treturn result;\n\t}\n\n\tprivate _serialize(destination: Uint8Array): void {\n\t\tlet offset = 0;\n\t\twriteUInt32BE(destination, this._tokens.length, offset); offset += 4;\n\t\tfor (let i = 0; i < this._tokens.length; i++) {\n\t\t\toffset = this._tokens[i].serialize(destination, offset);\n\t\t}\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as arrays from 'vs/base/common/arrays';\nimport { IdleDeadline, runWhenIdle } from 'vs/base/common/async';\nimport { BugIndicatingError, onUnexpectedError } from 'vs/base/common/errors';\nimport { Disposable, MutableDisposable } from 'vs/base/common/lifecycle';\nimport { setTimeout0 } from 'vs/base/common/platform';\nimport { StopWatch } from 'vs/base/common/stopwatch';\nimport { countEOL } from 'vs/editor/common/core/eolCounter';\nimport { Position } from 'vs/editor/common/core/position';\nimport { IRange } from 'vs/editor/common/core/range';\nimport { StandardTokenType } from 'vs/editor/common/encodedTokenAttributes';\nimport { EncodedTokenizationResult, IBackgroundTokenizationStore, IBackgroundTokenizer, ILanguageIdCodec, IState, ITokenizationSupport, TokenizationRegistry } from 'vs/editor/common/languages';\nimport { nullTokenizeEncoded } from 'vs/editor/common/languages/nullTokenize';\nimport { ITextModel } from 'vs/editor/common/model';\nimport { TextModel } from 'vs/editor/common/model/textModel';\nimport { TokenizationTextModelPart } from 'vs/editor/common/model/tokenizationTextModelPart';\nimport { IModelContentChangedEvent, IModelLanguageChangedEvent } from 'vs/editor/common/textModelEvents';\nimport { ContiguousMultilineTokensBuilder } from 'vs/editor/common/tokens/contiguousMultilineTokensBuilder';\nimport { LineTokens } from 'vs/editor/common/tokens/lineTokens';\n\nconst enum Constants {\n\tCHEAP_TOKENIZATION_LENGTH_LIMIT = 2048\n}\n\n/**\n * An array that avoids being sparse by always\n * filling up unused indices with a default value.\n */\nexport class ContiguousGrowingArray<T> {\n\n\tprivate _store: T[] = [];\n\n\tconstructor(\n\t\tprivate readonly _default: T\n\t) { }\n\n\tpublic get(index: number): T {\n\t\tif (index < this._store.length) {\n\t\t\treturn this._store[index];\n\t\t}\n\t\treturn this._default;\n\t}\n\n\tpublic set(index: number, value: T): void {\n\t\twhile (index >= this._store.length) {\n\t\t\tthis._store[this._store.length] = this._default;\n\t\t}\n\t\tthis._store[index] = value;\n\t}\n\n\t// TODO have `replace` instead of `delete` and `insert`\n\tpublic delete(deleteIndex: number, deleteCount: number): void {\n\t\tif (deleteCount === 0 || deleteIndex >= this._store.length) {\n\t\t\treturn;\n\t\t}\n\t\tthis._store.splice(deleteIndex, deleteCount);\n\t}\n\n\tpublic insert(insertIndex: number, insertCount: number): void {\n\t\tif (insertCount === 0 || insertIndex >= this._store.length) {\n\t\t\treturn;\n\t\t}\n\t\tconst arr: T[] = [];\n\t\tfor (let i = 0; i < insertCount; i++) {\n\t\t\tarr[i] = this._default;\n\t\t}\n\t\tthis._store = arrays.arrayInsert(this._store, insertIndex, arr);\n\t}\n}\n\n/**\n * Stores the states at the start of each line and keeps track of which lines\n * must be re-tokenized. Also uses state equality to quickly validate lines\n * that don't need to be re-tokenized.\n *\n * For example, when typing on a line, the line gets marked as needing to be tokenized.\n * Once the line is tokenized, the end state is checked for equality against the begin\n * state of the next line. If the states are equal, tokenization doesn't need to run\n * again over the rest of the file. If the states are not equal, the next line gets marked\n * as needing to be tokenized.\n */\nexport class TokenizationStateStore {\n\n\t/**\n\t * `lineBeginState[i]` contains the begin state used to tokenize line number `i + 1`.\n\t */\n\tprivate readonly _lineBeginState = new ContiguousGrowingArray<IState | null>(null);\n\t/**\n\t * `lineNeedsTokenization[i]` describes if line number `i + 1` needs to be tokenized.\n\t */\n\tprivate readonly _lineNeedsTokenization = new ContiguousGrowingArray<boolean>(true);\n\t/**\n\t * `invalidLineStartIndex` indicates that line number `invalidLineStartIndex + 1`\n\t *  is the first one that needs to be re-tokenized.\n\t */\n\tprivate _firstLineNeedsTokenization: number;\n\n\tpublic get invalidLineStartIndex() {\n\t\treturn this._firstLineNeedsTokenization;\n\t}\n\n\tconstructor(\n\t\tpublic readonly tokenizationSupport: ITokenizationSupport,\n\t\tpublic readonly initialState: IState\n\t) {\n\t\tthis._firstLineNeedsTokenization = 0;\n\t\tthis._lineBeginState.set(0, this.initialState);\n\t}\n\n\tpublic markMustBeTokenized(lineIndex: number): void {\n\t\tthis._lineNeedsTokenization.set(lineIndex, true);\n\t\tthis._firstLineNeedsTokenization = Math.min(this._firstLineNeedsTokenization, lineIndex);\n\t}\n\n\tpublic getBeginState(lineIndex: number): IState | null {\n\t\treturn this._lineBeginState.get(lineIndex);\n\t}\n\n\tpublic setEndState(linesLength: number, lineIndex: number, endState: IState): boolean {\n\t\tthis._lineNeedsTokenization.set(lineIndex, false);\n\t\tthis._firstLineNeedsTokenization = lineIndex + 1;\n\n\t\t// Check if this was the last line\n\t\tif (lineIndex === linesLength - 1) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Check if the end state has changed\n\t\tconst previousEndState = this._lineBeginState.get(lineIndex + 1);\n\t\tif (previousEndState === null || !endState.equals(previousEndState)) {\n\t\t\tthis._lineBeginState.set(lineIndex + 1, endState);\n\t\t\tthis.markMustBeTokenized(lineIndex + 1);\n\t\t\treturn true;\n\t\t}\n\n\t\t// Perhaps we can skip tokenizing some lines...\n\t\tlet i = lineIndex + 1;\n\t\twhile (i < linesLength) {\n\t\t\tif (this._lineNeedsTokenization.get(i)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tthis._firstLineNeedsTokenization = i;\n\t\treturn false;\n\t}\n\n\tpublic applyEdits(range: IRange, eolCount: number): void {\n\t\tthis.markMustBeTokenized(range.startLineNumber - 1);\n\n\t\tthis._lineBeginState.delete(range.startLineNumber, range.endLineNumber - range.startLineNumber);\n\t\tthis._lineNeedsTokenization.delete(range.startLineNumber, range.endLineNumber - range.startLineNumber);\n\n\t\tthis._lineBeginState.insert(range.startLineNumber, eolCount);\n\t\tthis._lineNeedsTokenization.insert(range.startLineNumber, eolCount);\n\t}\n\n\tpublic updateTokensUntilLine(textModel: ITextModel, languageIdCodec: ILanguageIdCodec, builder: ContiguousMultilineTokensBuilder, lineNumber: number): void {\n\t\tconst languageId = textModel.getLanguageId();\n\t\tconst linesLength = textModel.getLineCount();\n\t\tconst endLineIndex = lineNumber - 1;\n\n\t\t// Validate all states up to and including endLineIndex\n\t\tfor (let lineIndex = this.invalidLineStartIndex; lineIndex <= endLineIndex; lineIndex++) {\n\t\t\tconst text = textModel.getLineContent(lineIndex + 1);\n\t\t\tconst lineStartState = this.getBeginState(lineIndex);\n\n\t\t\tconst r = safeTokenize(languageIdCodec, languageId, this.tokenizationSupport, text, true, lineStartState!);\n\t\t\tbuilder.add(lineIndex + 1, r.tokens);\n\t\t\tthis.setEndState(linesLength, lineIndex, r.endState);\n\t\t\tlineIndex = this.invalidLineStartIndex - 1; // -1 because the outer loop increments it\n\t\t}\n\t}\n\n\tisTokenizationComplete(textModel: ITextModel): boolean {\n\t\treturn this.invalidLineStartIndex >= textModel.getLineCount();\n\t}\n}\n\nexport class TextModelTokenization extends Disposable {\n\n\tprivate _tokenizationStateStore: TokenizationStateStore | null = null;\n\tprivate _defaultBackgroundTokenizer: DefaultBackgroundTokenizer | null = null;\n\n\tprivate readonly backgroundTokenizer = this._register(new MutableDisposable<IBackgroundTokenizer>());\n\n\tconstructor(\n\t\tprivate readonly _textModel: TextModel,\n\t\tprivate readonly _tokenizationPart: TokenizationTextModelPart,\n\t\tprivate readonly _languageIdCodec: ILanguageIdCodec\n\t) {\n\t\tsuper();\n\n\t\tthis._register(TokenizationRegistry.onDidChange((e) => {\n\t\t\tconst languageId = this._textModel.getLanguageId();\n\t\t\tif (e.changedLanguages.indexOf(languageId) === -1) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis._resetTokenizationState();\n\t\t\tthis._tokenizationPart.clearTokens();\n\t\t}));\n\n\t\tthis._resetTokenizationState();\n\t}\n\n\tpublic handleDidChangeContent(e: IModelContentChangedEvent): void {\n\t\tif (e.isFlush) {\n\t\t\tthis._resetTokenizationState();\n\t\t\treturn;\n\t\t}\n\t\tif (this._tokenizationStateStore) {\n\t\t\tfor (let i = 0, len = e.changes.length; i < len; i++) {\n\t\t\t\tconst change = e.changes[i];\n\t\t\t\tconst [eolCount] = countEOL(change.text);\n\t\t\t\tthis._tokenizationStateStore.applyEdits(change.range, eolCount);\n\t\t\t}\n\t\t}\n\n\t\tthis._defaultBackgroundTokenizer?.handleChanges();\n\t}\n\n\tpublic handleDidChangeAttached(): void {\n\t\tthis._defaultBackgroundTokenizer?.handleChanges();\n\t}\n\n\tpublic handleDidChangeLanguage(e: IModelLanguageChangedEvent): void {\n\t\tthis._resetTokenizationState();\n\t\tthis._tokenizationPart.clearTokens();\n\t}\n\n\tprivate _resetTokenizationState(): void {\n\t\tconst [tokenizationSupport, initialState] = initializeTokenization(this._textModel, this._tokenizationPart);\n\t\tif (tokenizationSupport && initialState) {\n\t\t\tthis._tokenizationStateStore = new TokenizationStateStore(tokenizationSupport, initialState);\n\t\t} else {\n\t\t\tthis._tokenizationStateStore = null;\n\t\t}\n\n\t\tthis.backgroundTokenizer.clear();\n\n\t\tthis._defaultBackgroundTokenizer = null;\n\t\tif (this._tokenizationStateStore) {\n\t\t\tconst b: IBackgroundTokenizationStore = {\n\t\t\t\tsetTokens: (tokens) => {\n\t\t\t\t\tthis._tokenizationPart.setTokens(tokens);\n\t\t\t\t},\n\t\t\t\tbackgroundTokenizationFinished: () => {\n\t\t\t\t\tthis._tokenizationPart.handleBackgroundTokenizationFinished();\n\t\t\t\t},\n\t\t\t\tsetEndState: (lineNumber, state) => {\n\t\t\t\t\tif (!state) {\n\t\t\t\t\t\tthrow new BugIndicatingError();\n\t\t\t\t\t}\n\t\t\t\t\tconst invalidLineStartIndex = this._tokenizationStateStore?.invalidLineStartIndex;\n\t\t\t\t\tif (invalidLineStartIndex !== undefined && lineNumber - 1 >= invalidLineStartIndex) {\n\t\t\t\t\t\t// Don't accept states for definitely valid states\n\t\t\t\t\t\tthis._tokenizationStateStore?.setEndState(this._textModel.getLineCount(), lineNumber - 1, state);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t};\n\n\t\t\tif (tokenizationSupport && tokenizationSupport.createBackgroundTokenizer) {\n\t\t\t\tthis.backgroundTokenizer.value = tokenizationSupport.createBackgroundTokenizer(this._textModel, b);\n\t\t\t}\n\t\t\tif (!this.backgroundTokenizer.value) {\n\t\t\t\tthis.backgroundTokenizer.value = this._defaultBackgroundTokenizer =\n\t\t\t\t\tnew DefaultBackgroundTokenizer(\n\t\t\t\t\t\tthis._textModel,\n\t\t\t\t\t\tthis._tokenizationStateStore,\n\t\t\t\t\t\tb,\n\t\t\t\t\t\tthis._languageIdCodec\n\t\t\t\t\t);\n\t\t\t\tthis._defaultBackgroundTokenizer.handleChanges();\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic tokenizeViewport(startLineNumber: number, endLineNumber: number): void {\n\t\tconst builder = new ContiguousMultilineTokensBuilder();\n\t\tthis._heuristicallyTokenizeViewport(builder, startLineNumber, endLineNumber);\n\t\tthis._tokenizationPart.setTokens(builder.finalize());\n\t\tthis._defaultBackgroundTokenizer?.checkFinished();\n\t}\n\n\tpublic reset(): void {\n\t\tthis._resetTokenizationState();\n\t\tthis._tokenizationPart.clearTokens();\n\t}\n\n\tpublic forceTokenization(lineNumber: number): void {\n\t\tconst builder = new ContiguousMultilineTokensBuilder();\n\t\tthis._tokenizationStateStore?.updateTokensUntilLine(this._textModel, this._languageIdCodec, builder, lineNumber);\n\t\tthis._tokenizationPart.setTokens(builder.finalize());\n\t\tthis._defaultBackgroundTokenizer?.checkFinished();\n\t}\n\n\tpublic getTokenTypeIfInsertingCharacter(position: Position, character: string): StandardTokenType {\n\t\tif (!this._tokenizationStateStore) {\n\t\t\treturn StandardTokenType.Other;\n\t\t}\n\n\t\tthis.forceTokenization(position.lineNumber);\n\t\tconst lineStartState = this._tokenizationStateStore.getBeginState(position.lineNumber - 1);\n\t\tif (!lineStartState) {\n\t\t\treturn StandardTokenType.Other;\n\t\t}\n\n\t\tconst languageId = this._textModel.getLanguageId();\n\t\tconst lineContent = this._textModel.getLineContent(position.lineNumber);\n\n\t\t// Create the text as if `character` was inserted\n\t\tconst text = (\n\t\t\tlineContent.substring(0, position.column - 1)\n\t\t\t+ character\n\t\t\t+ lineContent.substring(position.column - 1)\n\t\t);\n\n\t\tconst r = safeTokenize(this._languageIdCodec, languageId, this._tokenizationStateStore.tokenizationSupport, text, true, lineStartState);\n\t\tconst lineTokens = new LineTokens(r.tokens, text, this._languageIdCodec);\n\t\tif (lineTokens.getCount() === 0) {\n\t\t\treturn StandardTokenType.Other;\n\t\t}\n\n\t\tconst tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n\t\treturn lineTokens.getStandardTokenType(tokenIndex);\n\t}\n\n\tpublic tokenizeLineWithEdit(position: Position, length: number, newText: string): LineTokens | null {\n\t\tconst lineNumber = position.lineNumber;\n\t\tconst column = position.column;\n\n\t\tif (!this._tokenizationStateStore) {\n\t\t\treturn null;\n\t\t}\n\n\t\tthis.forceTokenization(lineNumber);\n\t\tconst lineStartState = this._tokenizationStateStore.getBeginState(lineNumber - 1);\n\t\tif (!lineStartState) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst curLineContent = this._textModel.getLineContent(lineNumber);\n\t\tconst newLineContent = curLineContent.substring(0, column - 1)\n\t\t\t+ newText + curLineContent.substring(column - 1 + length);\n\n\t\tconst languageId = this._textModel.getLanguageIdAtPosition(lineNumber, 0);\n\t\tconst result = safeTokenize(\n\t\t\tthis._languageIdCodec,\n\t\t\tlanguageId,\n\t\t\tthis._tokenizationStateStore.tokenizationSupport,\n\t\t\tnewLineContent,\n\t\t\ttrue,\n\t\t\tlineStartState\n\t\t);\n\n\t\tconst lineTokens = new LineTokens(result.tokens, newLineContent, this._languageIdCodec);\n\t\treturn lineTokens;\n\t}\n\n\tpublic isCheapToTokenize(lineNumber: number): boolean {\n\t\tif (!this._tokenizationStateStore) {\n\t\t\treturn true;\n\t\t}\n\n\t\tconst firstInvalidLineNumber = this._tokenizationStateStore.invalidLineStartIndex + 1;\n\t\tif (lineNumber > firstInvalidLineNumber) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (lineNumber < firstInvalidLineNumber) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (this._textModel.getLineLength(lineNumber) < Constants.CHEAP_TOKENIZATION_LENGTH_LIMIT) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * The result is not cached.\n\t */\n\tprivate _heuristicallyTokenizeViewport(builder: ContiguousMultilineTokensBuilder, startLineNumber: number, endLineNumber: number): void {\n\t\tif (!this._tokenizationStateStore) {\n\t\t\t// nothing to do\n\t\t\treturn;\n\t\t}\n\t\tif (endLineNumber <= this._tokenizationStateStore.invalidLineStartIndex) {\n\t\t\t// nothing to do\n\t\t\treturn;\n\t\t}\n\n\t\tif (startLineNumber <= this._tokenizationStateStore.invalidLineStartIndex) {\n\t\t\t// tokenization has reached the viewport start...\n\t\t\tthis._tokenizationStateStore.updateTokensUntilLine(this._textModel, this._languageIdCodec, builder, endLineNumber);\n\t\t\treturn;\n\t\t}\n\n\t\tlet state = this.guessStartState(startLineNumber);\n\t\tconst languageId = this._textModel.getLanguageId();\n\n\t\tfor (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n\t\t\tconst text = this._textModel.getLineContent(lineNumber);\n\t\t\tconst r = safeTokenize(this._languageIdCodec, languageId, this._tokenizationStateStore.tokenizationSupport, text, true, state);\n\t\t\tbuilder.add(lineNumber, r.tokens);\n\t\t\tstate = r.endState;\n\t\t}\n\t\t// We overrode the tokens. Because old states might get reused (thus stopping invalidation),\n\t\t// we have to explicitly request the tokens for this range again.\n\t\tthis.backgroundTokenizer.value?.requestTokens(startLineNumber, endLineNumber + 1);\n\t}\n\n\tprivate guessStartState(lineNumber: number): IState {\n\t\tlet nonWhitespaceColumn = this._textModel.getLineFirstNonWhitespaceColumn(lineNumber);\n\t\tconst likelyRelevantLines: string[] = [];\n\t\tlet initialState: IState | null = null;\n\t\tfor (let i = lineNumber - 1; nonWhitespaceColumn > 1 && i >= 1; i--) {\n\t\t\tconst newNonWhitespaceIndex = this._textModel.getLineFirstNonWhitespaceColumn(i);\n\t\t\t// Ignore lines full of whitespace\n\t\t\tif (newNonWhitespaceIndex === 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (newNonWhitespaceIndex < nonWhitespaceColumn) {\n\t\t\t\tlikelyRelevantLines.push(this._textModel.getLineContent(i));\n\t\t\t\tnonWhitespaceColumn = newNonWhitespaceIndex;\n\t\t\t\tinitialState = this._tokenizationStateStore!.getBeginState(i - 1);\n\t\t\t\tif (initialState) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!initialState) {\n\t\t\tinitialState = this._tokenizationStateStore!.initialState;\n\t\t}\n\t\tlikelyRelevantLines.reverse();\n\n\t\tconst languageId = this._textModel.getLanguageId();\n\t\tlet state = initialState;\n\t\tfor (const line of likelyRelevantLines) {\n\t\t\tconst r = safeTokenize(this._languageIdCodec, languageId, this._tokenizationStateStore!.tokenizationSupport, line, false, state);\n\t\t\tstate = r.endState;\n\t\t}\n\t\treturn state;\n\t}\n}\n\nfunction initializeTokenization(textModel: TextModel, tokenizationPart: TokenizationTextModelPart): [ITokenizationSupport, IState] | [null, null] {\n\tif (textModel.isTooLargeForTokenization()) {\n\t\treturn [null, null];\n\t}\n\tconst tokenizationSupport = TokenizationRegistry.get(tokenizationPart.getLanguageId());\n\tif (!tokenizationSupport) {\n\t\treturn [null, null];\n\t}\n\tlet initialState: IState;\n\ttry {\n\t\tinitialState = tokenizationSupport.getInitialState();\n\t} catch (e) {\n\t\tonUnexpectedError(e);\n\t\treturn [null, null];\n\t}\n\treturn [tokenizationSupport, initialState];\n}\n\nfunction safeTokenize(languageIdCodec: ILanguageIdCodec, languageId: string, tokenizationSupport: ITokenizationSupport | null, text: string, hasEOL: boolean, state: IState): EncodedTokenizationResult {\n\tlet r: EncodedTokenizationResult | null = null;\n\n\tif (tokenizationSupport) {\n\t\ttry {\n\t\t\tr = tokenizationSupport.tokenizeEncoded(text, hasEOL, state.clone());\n\t\t} catch (e) {\n\t\t\tonUnexpectedError(e);\n\t\t}\n\t}\n\n\tif (!r) {\n\t\tr = nullTokenizeEncoded(languageIdCodec.encodeLanguageId(languageId), state);\n\t}\n\n\tLineTokens.convertToEndOffset(r.tokens, text.length);\n\treturn r;\n}\n\nclass DefaultBackgroundTokenizer implements IBackgroundTokenizer {\n\tprivate _isDisposed = false;\n\n\tconstructor(\n\t\tprivate readonly _textModel: ITextModel,\n\t\tprivate readonly _stateStore: TokenizationStateStore,\n\t\tprivate readonly _backgroundTokenStore: IBackgroundTokenizationStore,\n\t\tprivate readonly _languageIdCodec: ILanguageIdCodec,\n\t) {\n\t}\n\n\tpublic dispose(): void {\n\t\tthis._isDisposed = true;\n\t}\n\n\tpublic handleChanges(): void {\n\t\tthis._beginBackgroundTokenization();\n\t}\n\n\tprivate _isScheduled = false;\n\tprivate _beginBackgroundTokenization(): void {\n\t\tif (this._isScheduled || !this._textModel.isAttachedToEditor() || !this._hasLinesToTokenize()) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._isScheduled = true;\n\t\trunWhenIdle((deadline) => {\n\t\t\tthis._isScheduled = false;\n\n\t\t\tthis._backgroundTokenizeWithDeadline(deadline);\n\t\t});\n\t}\n\n\t/**\n\t * Tokenize until the deadline occurs, but try to yield every 1-2ms.\n\t */\n\tprivate _backgroundTokenizeWithDeadline(deadline: IdleDeadline): void {\n\t\t// Read the time remaining from the `deadline` immediately because it is unclear\n\t\t// if the `deadline` object will be valid after execution leaves this function.\n\t\tconst endTime = Date.now() + deadline.timeRemaining();\n\n\t\tconst execute = () => {\n\t\t\tif (this._isDisposed || !this._textModel.isAttachedToEditor() || !this._hasLinesToTokenize()) {\n\t\t\t\t// disposed in the meantime or detached or finished\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis._backgroundTokenizeForAtLeast1ms();\n\n\t\t\tif (Date.now() < endTime) {\n\t\t\t\t// There is still time before reaching the deadline, so yield to the browser and then\n\t\t\t\t// continue execution\n\t\t\t\tsetTimeout0(execute);\n\t\t\t} else {\n\t\t\t\t// The deadline has been reached, so schedule a new idle callback if necessary\n\t\t\t\tthis._beginBackgroundTokenization();\n\t\t\t}\n\t\t};\n\t\texecute();\n\t}\n\n\t/**\n\t * Tokenize for at least 1ms.\n\t */\n\tprivate _backgroundTokenizeForAtLeast1ms(): void {\n\t\tconst lineCount = this._textModel.getLineCount();\n\t\tconst builder = new ContiguousMultilineTokensBuilder();\n\t\tconst sw = StopWatch.create(false);\n\n\t\tdo {\n\t\t\tif (sw.elapsed() > 1) {\n\t\t\t\t// the comparison is intentionally > 1 and not >= 1 to ensure that\n\t\t\t\t// a full millisecond has elapsed, given how microseconds are rounded\n\t\t\t\t// to milliseconds\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tconst tokenizedLineNumber = this._tokenizeOneInvalidLine(builder);\n\n\t\t\tif (tokenizedLineNumber >= lineCount) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (this._hasLinesToTokenize());\n\n\t\tthis._backgroundTokenStore.setTokens(builder.finalize());\n\t\tthis.checkFinished();\n\t}\n\n\tprivate _hasLinesToTokenize(): boolean {\n\t\tif (!this._stateStore) {\n\t\t\treturn false;\n\t\t}\n\t\treturn this._stateStore.invalidLineStartIndex < this._textModel.getLineCount();\n\t}\n\n\tprivate _tokenizeOneInvalidLine(builder: ContiguousMultilineTokensBuilder): number {\n\t\tif (!this._stateStore || !this._hasLinesToTokenize()) {\n\t\t\treturn this._textModel.getLineCount() + 1;\n\t\t}\n\t\tconst lineNumber = this._stateStore.invalidLineStartIndex + 1;\n\t\tthis._stateStore.updateTokensUntilLine(this._textModel, this._languageIdCodec, builder, lineNumber);\n\t\treturn lineNumber;\n\t}\n\n\tpublic checkFinished(): void {\n\t\tif (this._isDisposed) {\n\t\t\treturn;\n\t\t}\n\t\tif (this._stateStore.isTokenizationComplete(this._textModel)) {\n\t\t\tthis._backgroundTokenStore.backgroundTokenizationFinished();\n\t\t}\n\t}\n\n\trequestTokens(startLineNumber: number, endLineNumberExclusive: number): void {\n\t\tfor (let lineNumber = startLineNumber; lineNumber < endLineNumberExclusive; lineNumber++) {\n\t\t\tthis._stateStore.markMustBeTokenized(lineNumber - 1);\n\t\t}\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Emitter, Event } from 'vs/base/common/event';\nimport { Disposable } from 'vs/base/common/lifecycle';\nimport { LanguageId, TokenMetadata } from 'vs/editor/common/encodedTokenAttributes';\nimport { EncodedTokenizationResult, IBackgroundTokenizationStore, IBackgroundTokenizer, IState, ITokenizationSupport, TokenizationResult } from 'vs/editor/common/languages';\nimport { ITextModel } from 'vs/editor/common/model';\nimport type { IGrammar, StateStack } from 'vscode-textmate';\n\nexport class TextMateTokenizationSupport extends Disposable implements ITokenizationSupport {\n\tprivate readonly _seenLanguages: boolean[] = [];\n\tprivate readonly _onDidEncounterLanguage: Emitter<LanguageId> = this._register(new Emitter<LanguageId>());\n\tpublic readonly onDidEncounterLanguage: Event<LanguageId> = this._onDidEncounterLanguage.event;\n\n\tconstructor(\n\t\tprivate readonly _grammar: IGrammar,\n\t\tprivate readonly _initialState: StateStack,\n\t\tprivate readonly _containsEmbeddedLanguages: boolean,\n\t\tprivate readonly _createBackgroundTokenizer?: (textModel: ITextModel, tokenStore: IBackgroundTokenizationStore) => IBackgroundTokenizer | undefined\n\t) {\n\t\tsuper();\n\t}\n\n\tpublic getInitialState(): IState {\n\t\treturn this._initialState;\n\t}\n\n\tpublic tokenize(line: string, hasEOL: boolean, state: IState): TokenizationResult {\n\t\tthrow new Error('Not supported!');\n\t}\n\n\tpublic createBackgroundTokenizer(textModel: ITextModel, store: IBackgroundTokenizationStore): IBackgroundTokenizer | undefined {\n\t\tif (this._createBackgroundTokenizer) {\n\t\t\treturn this._createBackgroundTokenizer(textModel, store);\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tpublic tokenizeEncoded(line: string, hasEOL: boolean, state: StateStack): EncodedTokenizationResult {\n\t\tconst textMateResult = this._grammar.tokenizeLine2(line, state, 500);\n\n\t\tif (textMateResult.stoppedEarly) {\n\t\t\tconsole.warn(`Time limit reached when tokenizing line: ${line.substring(0, 100)}`);\n\t\t\t// return the state at the beginning of the line\n\t\t\treturn new EncodedTokenizationResult(textMateResult.tokens, state);\n\t\t}\n\n\t\tif (this._containsEmbeddedLanguages) {\n\t\t\tconst seenLanguages = this._seenLanguages;\n\t\t\tconst tokens = textMateResult.tokens;\n\n\t\t\t// Must check if any of the embedded languages was hit\n\t\t\tfor (let i = 0, len = (tokens.length >>> 1); i < len; i++) {\n\t\t\t\tconst metadata = tokens[(i << 1) + 1];\n\t\t\t\tconst languageId = TokenMetadata.getLanguageId(metadata);\n\n\t\t\t\tif (!seenLanguages[languageId]) {\n\t\t\t\t\tseenLanguages[languageId] = true;\n\t\t\t\t\tthis._onDidEncounterLanguage.fire(languageId);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlet endState: StateStack;\n\t\t// try to save an object if possible\n\t\tif (state.equals(textMateResult.ruleStack)) {\n\t\t\tendState = state;\n\t\t} else {\n\t\t\tendState = textMateResult.ruleStack;\n\t\t}\n\n\t\treturn new EncodedTokenizationResult(textMateResult.tokens, endState);\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as resources from 'vs/base/common/resources';\nimport { URI } from 'vs/base/common/uri';\nimport { LanguageId, StandardTokenType } from 'vs/editor/common/encodedTokenAttributes';\n\nexport interface IValidGrammarDefinition {\n\tlocation: URI;\n\tlanguage?: string;\n\tscopeName: string;\n\tembeddedLanguages: IValidEmbeddedLanguagesMap;\n\ttokenTypes: IValidTokenTypeMap;\n\tinjectTo?: string[];\n\tbalancedBracketSelectors: string[];\n\tunbalancedBracketSelectors: string[];\n}\n\nexport interface IValidTokenTypeMap {\n\t[selector: string]: StandardTokenType;\n}\n\nexport interface IValidEmbeddedLanguagesMap {\n\t[scopeName: string]: LanguageId;\n}\n\nexport class TMScopeRegistry {\n\n\tprivate _scopeNameToLanguageRegistration: { [scopeName: string]: IValidGrammarDefinition };\n\n\tconstructor() {\n\t\tthis._scopeNameToLanguageRegistration = Object.create(null);\n\t}\n\n\tpublic reset(): void {\n\t\tthis._scopeNameToLanguageRegistration = Object.create(null);\n\t}\n\n\tpublic register(def: IValidGrammarDefinition): void {\n\t\tif (this._scopeNameToLanguageRegistration[def.scopeName]) {\n\t\t\tconst existingRegistration = this._scopeNameToLanguageRegistration[def.scopeName];\n\t\t\tif (!resources.isEqual(existingRegistration.location, def.location)) {\n\t\t\t\tconsole.warn(\n\t\t\t\t\t`Overwriting grammar scope name to file mapping for scope ${def.scopeName}.\\n` +\n\t\t\t\t\t`Old grammar file: ${existingRegistration.location.toString()}.\\n` +\n\t\t\t\t\t`New grammar file: ${def.location.toString()}`\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\tthis._scopeNameToLanguageRegistration[def.scopeName] = def;\n\t}\n\n\tpublic getGrammarDefinition(scopeName: string): IValidGrammarDefinition | null {\n\t\treturn this._scopeNameToLanguageRegistration[scopeName] || null;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { URI } from 'vs/base/common/uri';\nimport type { IGrammar, Registry, StateStack, IOnigLib, IRawTheme } from 'vscode-textmate';\nimport { Disposable } from 'vs/base/common/lifecycle';\nimport { TMScopeRegistry, IValidGrammarDefinition, IValidEmbeddedLanguagesMap } from 'vs/workbench/services/textMate/common/TMScopeRegistry';\n\ninterface ITMGrammarFactoryHost {\n\tlogTrace(msg: string): void;\n\tlogError(msg: string, err: any): void;\n\treadFile(resource: URI): Promise<string>;\n}\n\nexport interface ICreateGrammarResult {\n\tlanguageId: string;\n\tgrammar: IGrammar | null;\n\tinitialState: StateStack;\n\tcontainsEmbeddedLanguages: boolean;\n}\n\nexport const missingTMGrammarErrorMessage = 'No TM Grammar registered for this language.';\n\nexport class TMGrammarFactory extends Disposable {\n\n\tprivate readonly _host: ITMGrammarFactoryHost;\n\tprivate readonly _initialState: StateStack;\n\tprivate readonly _scopeRegistry: TMScopeRegistry;\n\tprivate readonly _injections: { [scopeName: string]: string[] };\n\tprivate readonly _injectedEmbeddedLanguages: { [scopeName: string]: IValidEmbeddedLanguagesMap[] };\n\tprivate readonly _languageToScope: Map<string, string>;\n\tprivate readonly _grammarRegistry: Registry;\n\n\tconstructor(host: ITMGrammarFactoryHost, grammarDefinitions: IValidGrammarDefinition[], vscodeTextmate: typeof import('vscode-textmate'), onigLib: Promise<IOnigLib>) {\n\t\tsuper();\n\t\tthis._host = host;\n\t\tthis._initialState = vscodeTextmate.INITIAL;\n\t\tthis._scopeRegistry = new TMScopeRegistry();\n\t\tthis._injections = {};\n\t\tthis._injectedEmbeddedLanguages = {};\n\t\tthis._languageToScope = new Map<string, string>();\n\t\tthis._grammarRegistry = this._register(new vscodeTextmate.Registry({\n\t\t\tonigLib: onigLib,\n\t\t\tloadGrammar: async (scopeName: string) => {\n\t\t\t\tconst grammarDefinition = this._scopeRegistry.getGrammarDefinition(scopeName);\n\t\t\t\tif (!grammarDefinition) {\n\t\t\t\t\tthis._host.logTrace(`No grammar found for scope ${scopeName}`);\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tconst location = grammarDefinition.location;\n\t\t\t\ttry {\n\t\t\t\t\tconst content = await this._host.readFile(location);\n\t\t\t\t\treturn vscodeTextmate.parseRawGrammar(content, location.path);\n\t\t\t\t} catch (e) {\n\t\t\t\t\tthis._host.logError(`Unable to load and parse grammar for scope ${scopeName} from ${location}`, e);\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t},\n\t\t\tgetInjections: (scopeName: string) => {\n\t\t\t\tconst scopeParts = scopeName.split('.');\n\t\t\t\tlet injections: string[] = [];\n\t\t\t\tfor (let i = 1; i <= scopeParts.length; i++) {\n\t\t\t\t\tconst subScopeName = scopeParts.slice(0, i).join('.');\n\t\t\t\t\tinjections = [...injections, ...(this._injections[subScopeName] || [])];\n\t\t\t\t}\n\t\t\t\treturn injections;\n\t\t\t}\n\t\t}));\n\n\t\tfor (const validGrammar of grammarDefinitions) {\n\t\t\tthis._scopeRegistry.register(validGrammar);\n\n\t\t\tif (validGrammar.injectTo) {\n\t\t\t\tfor (const injectScope of validGrammar.injectTo) {\n\t\t\t\t\tlet injections = this._injections[injectScope];\n\t\t\t\t\tif (!injections) {\n\t\t\t\t\t\tthis._injections[injectScope] = injections = [];\n\t\t\t\t\t}\n\t\t\t\t\tinjections.push(validGrammar.scopeName);\n\t\t\t\t}\n\n\t\t\t\tif (validGrammar.embeddedLanguages) {\n\t\t\t\t\tfor (const injectScope of validGrammar.injectTo) {\n\t\t\t\t\t\tlet injectedEmbeddedLanguages = this._injectedEmbeddedLanguages[injectScope];\n\t\t\t\t\t\tif (!injectedEmbeddedLanguages) {\n\t\t\t\t\t\t\tthis._injectedEmbeddedLanguages[injectScope] = injectedEmbeddedLanguages = [];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tinjectedEmbeddedLanguages.push(validGrammar.embeddedLanguages);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (validGrammar.language) {\n\t\t\t\tthis._languageToScope.set(validGrammar.language, validGrammar.scopeName);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic has(languageId: string): boolean {\n\t\treturn this._languageToScope.has(languageId);\n\t}\n\n\tpublic setTheme(theme: IRawTheme, colorMap: string[]): void {\n\t\tthis._grammarRegistry.setTheme(theme, colorMap);\n\t}\n\n\tpublic getColorMap(): string[] {\n\t\treturn this._grammarRegistry.getColorMap();\n\t}\n\n\tpublic async createGrammar(languageId: string, encodedLanguageId: number): Promise<ICreateGrammarResult> {\n\t\tconst scopeName = this._languageToScope.get(languageId);\n\t\tif (typeof scopeName !== 'string') {\n\t\t\t// No TM grammar defined\n\t\t\tthrow new Error(missingTMGrammarErrorMessage);\n\t\t}\n\n\t\tconst grammarDefinition = this._scopeRegistry.getGrammarDefinition(scopeName);\n\t\tif (!grammarDefinition) {\n\t\t\t// No TM grammar defined\n\t\t\tthrow new Error(missingTMGrammarErrorMessage);\n\t\t}\n\n\t\tconst embeddedLanguages = grammarDefinition.embeddedLanguages;\n\t\tif (this._injectedEmbeddedLanguages[scopeName]) {\n\t\t\tconst injectedEmbeddedLanguages = this._injectedEmbeddedLanguages[scopeName];\n\t\t\tfor (const injected of injectedEmbeddedLanguages) {\n\t\t\t\tfor (const scope of Object.keys(injected)) {\n\t\t\t\t\tembeddedLanguages[scope] = injected[scope];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst containsEmbeddedLanguages = (Object.keys(embeddedLanguages).length > 0);\n\n\t\tlet grammar: IGrammar | null;\n\n\t\ttry {\n\t\t\tgrammar = await this._grammarRegistry.loadGrammarWithConfiguration(\n\t\t\t\tscopeName,\n\t\t\t\tencodedLanguageId,\n\t\t\t\t{\n\t\t\t\t\tembeddedLanguages,\n\t\t\t\t\ttokenTypes: <any>grammarDefinition.tokenTypes,\n\t\t\t\t\tbalancedBracketSelectors: grammarDefinition.balancedBracketSelectors,\n\t\t\t\t\tunbalancedBracketSelectors: grammarDefinition.unbalancedBracketSelectors,\n\t\t\t\t}\n\t\t\t);\n\t\t} catch (err) {\n\t\t\tif (err.message && err.message.startsWith('No grammar provided for')) {\n\t\t\t\t// No TM grammar defined\n\t\t\t\tthrow new Error(missingTMGrammarErrorMessage);\n\t\t\t}\n\t\t\tthrow err;\n\t\t}\n\n\t\treturn {\n\t\t\tlanguageId: languageId,\n\t\t\tgrammar: grammar,\n\t\t\tinitialState: this._initialState,\n\t\t\tcontainsEmbeddedLanguages: containsEmbeddedLanguages\n\t\t};\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { URI } from 'vs/base/common/uri';\nimport { LanguageId } from 'vs/editor/common/encodedTokenAttributes';\nimport { IModelChangedEvent, MirrorTextModel } from 'vs/editor/common/model/mirrorTextModel';\nimport { TokenizationStateStore } from 'vs/editor/common/model/textModelTokens';\nimport { diffStateStacksRefEq, StateStack, StackDiff } from 'vscode-textmate';\nimport { ContiguousMultilineTokensBuilder } from 'vs/editor/common/tokens/contiguousMultilineTokensBuilder';\nimport { countEOL } from 'vs/editor/common/core/eolCounter';\nimport { LineTokens } from 'vs/editor/common/tokens/lineTokens';\nimport { TextMateTokenizationSupport } from 'vs/workbench/services/textMate/browser/tokenizationSupport/textMateTokenizationSupport';\nimport { StateDeltas } from 'vs/workbench/services/textMate/browser/workerHost/textMateWorkerHost';\nimport { RunOnceScheduler } from 'vs/base/common/async';\nimport { TextMateTokenizationWorker } from './textMate.worker';\n\nexport class TextMateWorkerModel extends MirrorTextModel {\n\tprivate _tokenizationStateStore: TokenizationStateStore | null;\n\tprivate readonly _worker: TextMateTokenizationWorker;\n\tprivate _languageId: string;\n\tprivate _encodedLanguageId: LanguageId;\n\tprivate _isDisposed: boolean;\n\n\tconstructor(uri: URI, lines: string[], eol: string, versionId: number, worker: TextMateTokenizationWorker, languageId: string, encodedLanguageId: LanguageId) {\n\t\tsuper(uri, lines, eol, versionId);\n\t\tthis._tokenizationStateStore = null;\n\t\tthis._worker = worker;\n\t\tthis._languageId = languageId;\n\t\tthis._encodedLanguageId = encodedLanguageId;\n\t\tthis._isDisposed = false;\n\t\tthis._resetTokenization();\n\t}\n\n\tpublic override dispose(): void {\n\t\tthis._isDisposed = true;\n\t\tsuper.dispose();\n\t}\n\n\tpublic onLanguageId(languageId: string, encodedLanguageId: LanguageId): void {\n\t\tthis._languageId = languageId;\n\t\tthis._encodedLanguageId = encodedLanguageId;\n\t\tthis._resetTokenization();\n\t}\n\n\tprivate readonly tokenizeDebouncer = new RunOnceScheduler(() => this._tokenize(), 10);\n\n\toverride onEvents(e: IModelChangedEvent): void {\n\t\tsuper.onEvents(e);\n\t\tif (this._tokenizationStateStore) {\n\t\t\t// Changes are sorted in descending order\n\t\t\tfor (let i = 0; i < e.changes.length; i++) {\n\t\t\t\tconst change = e.changes[i];\n\t\t\t\tconst [eolCount] = countEOL(change.text);\n\t\t\t\tthis._tokenizationStateStore.applyEdits(change.range, eolCount);\n\t\t\t}\n\t\t}\n\t\tthis.tokenizeDebouncer.schedule();\n\t}\n\n\tpublic retokenize(startLineNumber: number, endLineNumberExclusive: number) {\n\t\tif (this._tokenizationStateStore) {\n\t\t\tfor (let lineNumber = startLineNumber; lineNumber < endLineNumberExclusive; lineNumber++) {\n\t\t\t\tthis._tokenizationStateStore.markMustBeTokenized(lineNumber - 1);\n\t\t\t}\n\t\t\tthis.tokenizeDebouncer.schedule();\n\t\t}\n\t}\n\n\tprivate _resetTokenization(): void {\n\t\tthis._tokenizationStateStore = null;\n\n\t\tconst languageId = this._languageId;\n\t\tconst encodedLanguageId = this._encodedLanguageId;\n\t\tthis._worker.getOrCreateGrammar(languageId, encodedLanguageId).then((r) => {\n\t\t\tif (this._isDisposed || languageId !== this._languageId || encodedLanguageId !== this._encodedLanguageId || !r) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (r.grammar) {\n\t\t\t\tconst tokenizationSupport = new TextMateTokenizationSupport(r.grammar, r.initialState, false);\n\t\t\t\tthis._tokenizationStateStore = new TokenizationStateStore(tokenizationSupport, tokenizationSupport.getInitialState());\n\t\t\t} else {\n\t\t\t\tthis._tokenizationStateStore = null;\n\t\t\t}\n\t\t\tthis._tokenize();\n\t\t});\n\t}\n\n\tprivate _tokenize(): void {\n\t\tif (this._isDisposed || !this._tokenizationStateStore) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst startTime = new Date().getTime();\n\n\t\twhile (true) {\n\t\t\tconst builder = new ContiguousMultilineTokensBuilder();\n\t\t\tconst lineCount = this._lines.length;\n\n\t\t\tlet tokenizedLines = 0;\n\n\t\t\tconst stateDeltaBuilder = new StateDeltaBuilder();\n\n\t\t\t// Validate all states up to and including endLineIndex\n\t\t\twhile (this._tokenizationStateStore.invalidLineStartIndex < lineCount) {\n\t\t\t\tconst lineIndex = this._tokenizationStateStore.invalidLineStartIndex;\n\n\t\t\t\ttokenizedLines++;\n\t\t\t\t// TODO don't spam the renderer\n\t\t\t\tif (tokenizedLines > 200) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tconst text = this._lines[lineIndex];\n\n\t\t\t\tconst lineStartState = this._tokenizationStateStore.getBeginState(lineIndex) as StateStack;\n\t\t\t\tconst tokenizeResult = this._tokenizationStateStore.tokenizationSupport.tokenizeEncoded(text, true, lineStartState);\n\t\t\t\tif (this._tokenizationStateStore.setEndState(lineCount, lineIndex, tokenizeResult.endState)) {\n\t\t\t\t\tconst delta = diffStateStacksRefEq(lineStartState, tokenizeResult.endState as StateStack);\n\t\t\t\t\tstateDeltaBuilder.setState(lineIndex + 1, delta);\n\t\t\t\t}\n\n\t\t\t\tLineTokens.convertToEndOffset(tokenizeResult.tokens, text.length);\n\t\t\t\tbuilder.add(lineIndex + 1, tokenizeResult.tokens);\n\n\t\t\t\tconst deltaMs = new Date().getTime() - startTime;\n\t\t\t\tif (deltaMs > 20) {\n\t\t\t\t\t// yield to check for changes\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (tokenizedLines === 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tconst stateDeltas = stateDeltaBuilder.getStateDeltas();\n\t\t\tthis._worker.setTokensAndStates(this._uri, this._versionId, builder.serialize(), stateDeltas);\n\n\t\t\tconst deltaMs = new Date().getTime() - startTime;\n\t\t\tif (deltaMs > 20) {\n\t\t\t\t// yield to check for changes\n\t\t\t\tsetTimeout(() => this._tokenize(), 3);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}\n\nclass StateDeltaBuilder {\n\tprivate _lastStartLineNumber: number = -1;\n\tprivate _stateDeltas: StateDeltas[] = [];\n\n\tpublic setState(lineNumber: number, stackDiff: StackDiff): void {\n\t\tif (lineNumber === this._lastStartLineNumber + 1) {\n\t\t\tthis._stateDeltas[this._stateDeltas.length - 1].stateDeltas.push(stackDiff);\n\t\t} else {\n\t\t\tthis._stateDeltas.push({ startLineNumber: lineNumber, stateDeltas: [stackDiff] });\n\t\t}\n\t\tthis._lastStartLineNumber = lineNumber;\n\t}\n\n\tpublic getStateDeltas(): StateDeltas[] {\n\t\treturn this._stateDeltas;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { URI, UriComponents } from 'vs/base/common/uri';\nimport { LanguageId } from 'vs/editor/common/encodedTokenAttributes';\nimport { IModelChangedEvent } from 'vs/editor/common/model/mirrorTextModel';\nimport { IWorkerContext } from 'vs/editor/common/services/editorSimpleWorker';\nimport type { StateDeltas, TextMateWorkerHost } from 'vs/workbench/services/textMate/browser/workerHost/textMateWorkerHost';\nimport { ICreateGrammarResult, TMGrammarFactory } from 'vs/workbench/services/textMate/common/TMGrammarFactory';\nimport { IValidEmbeddedLanguagesMap, IValidGrammarDefinition, IValidTokenTypeMap } from 'vs/workbench/services/textMate/common/TMScopeRegistry';\nimport { IOnigLib, IRawTheme } from 'vscode-textmate';\nimport { TextMateWorkerModel } from './textMateWorkerModel';\n\nexport interface ICreateData {\n\tgrammarDefinitions: IValidGrammarDefinitionDTO[];\n\ttextmateMainUri: string;\n\tonigurumaMainUri: string;\n\tonigurumaWASMUri: string;\n}\n\nexport interface IValidGrammarDefinitionDTO {\n\tlocation: UriComponents;\n\tlanguage?: string;\n\tscopeName: string;\n\tembeddedLanguages: IValidEmbeddedLanguagesMap;\n\ttokenTypes: IValidTokenTypeMap;\n\tinjectTo?: string[];\n\tbalancedBracketSelectors: string[];\n\tunbalancedBracketSelectors: string[];\n}\n\nexport class TextMateTokenizationWorker {\n\n\tprivate readonly _host: TextMateWorkerHost;\n\tprivate readonly _models: { [uri: string]: TextMateWorkerModel } = Object.create(null);\n\tprivate readonly _grammarCache: Promise<ICreateGrammarResult>[] = [];\n\tprivate readonly _grammarFactory: Promise<TMGrammarFactory | null>;\n\n\tconstructor(ctx: IWorkerContext<TextMateWorkerHost>, private readonly createData: ICreateData) {\n\t\tthis._host = ctx.host;\n\t\tconst grammarDefinitions = createData.grammarDefinitions.map<IValidGrammarDefinition>((def) => {\n\t\t\treturn {\n\t\t\t\tlocation: URI.revive(def.location),\n\t\t\t\tlanguage: def.language,\n\t\t\t\tscopeName: def.scopeName,\n\t\t\t\tembeddedLanguages: def.embeddedLanguages,\n\t\t\t\ttokenTypes: def.tokenTypes,\n\t\t\t\tinjectTo: def.injectTo,\n\t\t\t\tbalancedBracketSelectors: def.balancedBracketSelectors,\n\t\t\t\tunbalancedBracketSelectors: def.unbalancedBracketSelectors,\n\t\t\t};\n\t\t});\n\t\tthis._grammarFactory = this._loadTMGrammarFactory(grammarDefinitions);\n\t}\n\n\tprivate async _loadTMGrammarFactory(grammarDefinitions: IValidGrammarDefinition[]): Promise<TMGrammarFactory> {\n\t\tconst uri = this.createData.textmateMainUri;\n\t\tconst vscodeTextmate = await import(uri);\n\t\tconst vscodeOniguruma = await import(this.createData.onigurumaMainUri);\n\t\tconst response = await fetch(this.createData.onigurumaWASMUri);\n\n\t\t// Using the response directly only works if the server sets the MIME type 'application/wasm'.\n\t\t// Otherwise, a TypeError is thrown when using the streaming compiler.\n\t\t// We therefore use the non-streaming compiler :(.\n\t\tconst bytes = await response.arrayBuffer();\n\t\tawait vscodeOniguruma.loadWASM(bytes);\n\n\t\tconst onigLib: Promise<IOnigLib> = Promise.resolve({\n\t\t\tcreateOnigScanner: (sources) => vscodeOniguruma.createOnigScanner(sources),\n\t\t\tcreateOnigString: (str) => vscodeOniguruma.createOnigString(str)\n\t\t});\n\n\t\treturn new TMGrammarFactory({\n\t\t\tlogTrace: (msg: string) => {/* console.log(msg) */ },\n\t\t\tlogError: (msg: string, err: any) => console.error(msg, err),\n\t\t\treadFile: (resource: URI) => this._host.readFile(resource)\n\t\t}, grammarDefinitions, vscodeTextmate, onigLib);\n\t}\n\n\t// #region called by renderer\n\n\tpublic acceptNewModel(data: IRawModelData): void {\n\t\tconst uri = URI.revive(data.uri);\n\t\tconst key = uri.toString();\n\t\tthis._models[key] = new TextMateWorkerModel(uri, data.lines, data.EOL, data.versionId, this, data.languageId, data.encodedLanguageId);\n\t}\n\n\tpublic acceptModelChanged(strURL: string, e: IModelChangedEvent): void {\n\t\tthis._models[strURL].onEvents(e);\n\t}\n\n\tpublic retokenize(strURL: string, startLineNumber: number, endLineNumberExclusive: number): void {\n\t\tthis._models[strURL].retokenize(startLineNumber, endLineNumberExclusive);\n\t}\n\n\tpublic acceptModelLanguageChanged(strURL: string, newLanguageId: string, newEncodedLanguageId: LanguageId): void {\n\t\tthis._models[strURL].onLanguageId(newLanguageId, newEncodedLanguageId);\n\t}\n\n\tpublic acceptRemovedModel(strURL: string): void {\n\t\tif (this._models[strURL]) {\n\t\t\tthis._models[strURL].dispose();\n\t\t\tdelete this._models[strURL];\n\t\t}\n\t}\n\n\tpublic async acceptTheme(theme: IRawTheme, colorMap: string[]): Promise<void> {\n\t\tconst grammarFactory = await this._grammarFactory;\n\t\tgrammarFactory?.setTheme(theme, colorMap);\n\t}\n\n\t// #endregion\n\n\t// #region called by worker model\n\n\tpublic async getOrCreateGrammar(languageId: string, encodedLanguageId: LanguageId): Promise<ICreateGrammarResult | null> {\n\t\tconst grammarFactory = await this._grammarFactory;\n\t\tif (!grammarFactory) {\n\t\t\treturn Promise.resolve(null);\n\t\t}\n\t\tif (!this._grammarCache[encodedLanguageId]) {\n\t\t\tthis._grammarCache[encodedLanguageId] = grammarFactory.createGrammar(languageId, encodedLanguageId);\n\t\t}\n\t\treturn this._grammarCache[encodedLanguageId];\n\t}\n\n\tpublic setTokensAndStates(resource: URI, versionId: number, tokens: Uint8Array, stateDeltas: StateDeltas[]): void {\n\t\tthis._host.setTokensAndStates(resource, versionId, tokens, stateDeltas);\n\t}\n\n\t// #endregion\n}\n\nexport interface IRawModelData {\n\turi: UriComponents;\n\tversionId: number;\n\tlines: string[];\n\tEOL: string;\n\tlanguageId: string;\n\tencodedLanguageId: LanguageId;\n}\n\nexport function create(ctx: IWorkerContext<TextMateWorkerHost>, createData: ICreateData): TextMateTokenizationWorker {\n\treturn new TextMateTokenizationWorker(ctx, createData);\n}\n"],"mappings":"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","names":["__m","__M","deps","result","i","len","isReadable","obj","candidate","exports","isReadableStream","fn","isReadableBufferedStream","newWriteableStream","reducer","options","WriteableStreamImpl","e","f","data","resolve","error","listener","errors_1","event","callback","listeners","index","fullDataBuffer","pendingWritePromises","pendingWritePromise","consumeReadable","readable","chunks","chunk","peekReadable","maxChunks","lastReadChunk","consumeStream","stream","reject","listenStream","destroyed","lifecycle_1","peekStream","streamListeners","buffer","dataListener","errorListener","endListener","toStream","t","emptyStream","toReadable","consumed","transform","transformer","target","prefixedReadable","prefix","prefixHandled","prefixedStream","hasBuffer","textEncoder","textDecoder","VSBuffer","byteLength","actual","source","buffers","totalLength","ret","offset","element","start","end","array","readUInt32BE","value","writeUInt32BE","readUInt32LE","writeUInt32LE","readUInt8","writeUInt8","readUInt16LE","writeUInt16LE","destination","readableToBuffer","streams","bufferToReadable","streamToBuffer","bufferedStreamToBuffer","bufferedStream","bufferToStream","streamToBufferReadableStream","newWriteableBufferStream","prefixedBufferReadable","prefixedBufferStream","decodeBase64","encoded","building","remainder","bufi","append","code","unpadded","base64Alphabet","base64UrlSafeAlphabet","encodeBase64","padded","urlSafe","dictionary","output","a","b","c","isPathSeparator","toSlashes","osPath","path_1","toPosixPath","getRoot","path","sep","firstLetter","pos","isWindowsDriveLetter","isUNC","platform_1","WINDOWS_INVALID_FILE_CHARS","UNIX_INVALID_FILE_CHARS","WINDOWS_FORBIDDEN_NAMES","isValidBasename","name","isWindowsOS","invalidFileChars","isEqual","pathA","pathB","ignoreCase","identityEquals","strings_1","isEqualOrParent","base","parentCandidate","separator","sepOffset","char0","sanitizeFilePath","cwd","isRootOrDriveLetter","pathNormalized","hasDriveLetter","getDriveLetter","indexOfPath","parseLineAndColumnAware","rawPath","segments","line","column","segment","segmentAsNumber","types_1","pathChars","randomPath","parent","randomLength","suffix","randomFileName","Schemas","RemoteAuthoritiesImpl","schema","delegate","serverRootPath","authority","host","port","connectionToken","uri","err","errors","query","uri_1","platform","FileAccessImpl","resourcePath","require","uriOrModule","moduleIdToUrl","COI","coiHeaders","coiSearchParamName","getHeadersFromQuery","url","params","addSearchParam","urlOrSearch","coop","coep","originalFSPath","ExtUri","uri1","uri2","ignoreFragment","network_1","extpath","resource","pathFragment","paths","dirname","normalizedPath","from","to","relativePath","fromPath","toPath","newURI","a1","a2","fsp","p","isRootSep","_","distinctParents","items","resourceAccessor","candidateResource","otherItem","DataUri","parseMetaData","dataUri","metadata","property","key","mime","toLocalResource","localScheme","isThenable","createCancelablePromise","cancellation_1","thenable","promise","subscription","onfinally","raceCancellation","token","defaultValue","ref","raceCancellationError","raceCancellablePromises","cancellablePromises","resolvedPromiseIndex","promises","cancellablePromise","raceTimeout","timeout","onTimeout","promiseResolve","timer","asPromise","item","Throttler","promiseFactory","onComplete","Sequencer","promiseTask","SequencerByKey","newPromise","timeoutDeferred","scheduled","handle","microtaskDeferred","Delayer","defaultDelay","task","delay","symbols_1","ThrottledDelayer","Barrier","AutoOpenBarrier","autoOpenTimeMs","millis","disposable","disposableTimeout","handler","sequence","promiseFactories","results","next","thenHandler","n","first","shouldStop","loop","factory","firstParallel","promiseList","todo","finish","Limiter","maxDegreeOfParalellism","event_1","iLimitedTask","Queue","ResourceQueue","DeferredPromise","queue","extUri","resources_1","drainer","TimeoutTimer","runner","IntervalTimer","interval","RunOnceScheduler","ProcessTimeRunOnceScheduler","RunOnceWorker","unit","units","ThrottledWorker","g","h","disposed","IdleValue","executor","retry","retries","lastError","TaskSequentializer","taskId","onCancel","run","promiseReject","IntervalCounter","d","now","Promises","settled","firstError","withAsyncBody","bodyFn","AsyncIterableSourceState","AsyncIterableObject","writer","emitter","iterables","iterable","mapFn","filterFn","values","CancelableAsyncIterableObject","l","createCancelableAsyncIterable","innerIterable","StringEOL","countEOL","text","eolCount","firstLineLength","lastLineStart","eol","chr","LanguageId","FontStyle","ColorId","StandardTokenType","MetadataConsts","TokenMetadata","foreground","className","fontStyle","colorMap","textDecoration","other","nullTokenize","languageId","state","languages_1","nullTokenizeEncoded","tokens","LineTokens","lineContent","decoder","defaultMetadata","sliceFromTokenIndex","sliceTokenCount","tokenIndex","encodedTokenAttributes_1","startOffset","endOffset","deltaOffset","SliceLineTokens","lineTextLength","lastTokenIndex","desiredIndex","low","high","mid","insertTokens","nextOriginalTokenIdx","nextInsertTokenIdx","newTokens","originalEndOffset","nextOriginalTokenEndOffset","nextInsertToken","tokenEndOffset","ContiguousTokensEditing","lineTokens","toChIndex","fromChIndex","toUint32Array","tokensCount","fromTokenIndex","lineTokens_1","fromTokenStartOffset","fromTokenEndOffset","delta","dest","lastEnd","tmp","_otherTokens","myTokens","otherTokens","otherTokensCount","chIndex","textLength","arr","ContiguousMultilineTokens","buff","view32","startLineNumber","buffer_1","count","byteCount","lineNumber","range","eolCounter_1","position_1","firstLineIndex","lastLineIndex","deletedLinesCount","contiguousTokensEditing_1","lastLineTokens","deletedBefore","position","lineIndex","insertIndex","insertCount","arrays","ContiguousMultilineTokensBuilder","contiguousMultilineTokens_1","last","size","Constants","ContiguousGrowingArray","deleteIndex","deleteCount","TokenizationStateStore","tokenizationSupport","initialState","linesLength","endState","previousEndState","textModel","languageIdCodec","builder","endLineIndex","lineStartState","r","safeTokenize","TextModelTokenization","j","change","initializeTokenization","invalidLineStartIndex","DefaultBackgroundTokenizer","endLineNumber","contiguousMultilineTokensBuilder_1","character","length","newText","curLineContent","newLineContent","firstInvalidLineNumber","nonWhitespaceColumn","likelyRelevantLines","newNonWhitespaceIndex","tokenizationPart","hasEOL","nullTokenize_1","async_1","deadline","endTime","execute","lineCount","sw","stopwatch_1","endLineNumberExclusive","TextMateTokenizationSupport","store","textMateResult","seenLanguages","TMScopeRegistry","def","existingRegistration","resources","scopeName","TMGrammarFactory","grammarDefinitions","vscodeTextmate","onigLib","TMScopeRegistry_1","grammarDefinition","location","content","scopeParts","injections","subScopeName","validGrammar","injectScope","injectedEmbeddedLanguages","theme","encodedLanguageId","embeddedLanguages","injected","scope","containsEmbeddedLanguages","grammar","TextMateWorkerModel","mirrorTextModel_1","lines","versionId","worker","textMateTokenizationSupport_1","textModelTokens_1","startTime","tokenizedLines","stateDeltaBuilder","StateDeltaBuilder","tokenizeResult","vscode_textmate_1","stateDeltas","stackDiff","TextMateTokenizationWorker","ctx","resolve_1","reject_1","vscodeOniguruma","resolve_2","reject_2","bytes","sources","str","TMGrammarFactory_1","msg","textMateWorkerModel_1","strURL","newLanguageId","newEncodedLanguageId","grammarFactory","create","createData"],"file":"textMate.worker.js"}